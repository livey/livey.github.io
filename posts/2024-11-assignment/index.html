<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Assignment Problem and Primal-Dual Algorithm | Fuwei's Tech Notes</title>
<meta name=keywords content="Assignment Problem,Signal Processing,Optimization,Hungarian Algorithm,Primal-Dual Algorithm"><meta name=description content="Hungarian algorithm, prime-dual interpretation, and the gated Hungarian algorithm"><meta name=author content="Fuwei Li"><link rel=canonical href=https://livey.github.io><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://livey.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://livey.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://livey.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://livey.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://livey.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://livey.github.io/posts/2024-11-assignment/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="index, follow"><meta name=author content="Fuwei Li"><meta name=description content="Hungarian algorithm, prime-dual interpretation, and the gated Hungarian algorithm"><meta property="og:type" content="article"><meta property="og:url" content="https://livey.github.io/posts/2024-11-assignment/"><meta property="og:title" content="The Assignment Problem and Primal-Dual Algorithm"><meta property="og:description" content="Hungarian algorithm, prime-dual interpretation, and the gated Hungarian algorithm"><meta property="og:image" content="https://livey.github.io/images/site-preview.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="The Assignment Problem and Primal-Dual Algorithm"><meta name=twitter:description content="Hungarian algorithm, prime-dual interpretation, and the gated Hungarian algorithm"><meta name=twitter:image content="https://livey.github.io/images/site-preview.jpg"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://livey.github.io/posts/2024-11-assignment/"><meta property="og:site_name" content="Fuwei's Tech Notes"><meta property="og:title" content="The Assignment Problem and Primal-Dual Algorithm"><meta property="og:description" content="Hungarian algorithm, prime-dual interpretation, and the gated Hungarian algorithm"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-20T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-20T00:00:00+00:00"><meta property="article:tag" content="Assignment Problem"><meta property="article:tag" content="Signal Processing"><meta property="article:tag" content="Optimization"><meta property="article:tag" content="Hungarian Algorithm"><meta property="article:tag" content="Primal-Dual Algorithm"><meta property="og:image" content="https://livey.github.io/posts/2024-11-assignment/%3Cimage%20path/url%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://livey.github.io/posts/2024-11-assignment/%3Cimage%20path/url%3E"><meta name=twitter:title content="The Assignment Problem and Primal-Dual Algorithm"><meta name=twitter:description content="Hungarian algorithm, prime-dual interpretation, and the gated Hungarian algorithm"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://livey.github.io/posts/"},{"@type":"ListItem","position":2,"name":"The Assignment Problem and Primal-Dual Algorithm","item":"https://livey.github.io/posts/2024-11-assignment/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Assignment Problem and Primal-Dual Algorithm","name":"The Assignment Problem and Primal-Dual Algorithm","description":"Hungarian algorithm, prime-dual interpretation, and the gated Hungarian algorithm","keywords":["Assignment Problem","Signal Processing","Optimization","Hungarian Algorithm","Primal-Dual Algorithm"],"articleBody":"This post discusses the assignment problem, its primal-dual interpretation, and the gated Hungarian algorithm.\nTutor HungarianAlgorithm and [4] gives a nice interpretation of the dual-prime of the Hungarian algorithm.\nPrime-Dual Interpretation of Hungarian Algorithm The following linear program gives a lower bound on the optimal value of the assignment problem:\n$$\\begin{array}{ll} \\min \u0026 \\sum_{i \\in I} \\sum_{j \\in J} c_{i j} x_{i j} \\\\ \\text { s.t. } \u0026 \\sum_{j \\in J} x_{i j}=1 \\text { for all } i \\in I \\\\ \u0026 \\sum_{i \\in I} x_{i j}=1 \\text { for all } j \\in J \\\\ \u0026 x_{i j} \\geq 0 \\end{array}$$To see this, note that we can let $x_{i j}=1$ if $i$ is assigned to $j$ and 0 otherwise. Clearly, this is a feasible solution to the L.P, so the optimal value of the LP must be at most the optimal value of the assignment problem.\nWe consider the dual of the L.P:\n$$\\begin{array}{ll} \\max \u0026 \\sum_{i \\in I} u_i+\\sum_{j \\in J} v_j \\\\ \\text { s.t. } \u0026 u_i+v_j \\leq c_{i j} \\text { for all } i \\in I, j \\in J \\end{array}$$Now, we know that $x$ is an optimal solution to the primal L.P and $u, v$ is an optimal solution to the dual LP if and only if (i) $x$ is feasible for the primal LP, (ii) $u, v$ is feasible for the dual LP, (iii) the primal and dual solutions obey complementary slackness.\nThinking about what these conditions mean for the assignment problem allows us to formulate the Hungarian algorithm in a much more general way:\nWe maintain a feasible dual solution. We let $u_i$ be the amount subtracted from row $i$ and $v_j$ is the amount subtracted from column $j$. Feasibility means that we must ensure that $\\bar{c}_{i j}=c_{i j}-u_i-v_j$ is non-negative for all $(i, j)$.\nWe try to find a primal solution $x$ that satisfies complementary slackness with respect to the current dual solution. Complementary slackness for the assignment problem means that we try to find an assignment that only uses edges with $\\bar{c}_{i j}=0$, i.e., we solve the maximum cardinality bipartite matching problem on the graph that contains a node for every $i \\in I, j \\in J$ and an edge $(i, j)$ if $\\bar{c}_{i j}=0$. We either find a perfect matching, or we get a vertex cover of size $ \u003c n$.\nIf we can not find such a primal solution, we find a direction of dual increase. The vertex cover in the bipartite matching instance corresponds to $I^{\\prime}, J^{\\prime}$, a subset of the rows and columns, such that $\\left|I^{\\prime}\\right|+\\left|J^{\\prime}\\right| \u003c n$ and if $\\bar{c}_{ij}=0$ then $i \\in I^{\\prime}$ or $j \\in J^{\\prime}$. We let $\\alpha = \\min_{(i,j): i\\notin I^\\prime, j\\notin J^\\prime} \\bar{c}_{i,j}$, and we update\n$$u_i \\leftarrow u_i-\\alpha \\text { for all } i \\notin I^{\\prime}, \\quad v_j \\leftarrow v_j+\\alpha \\text { for all } j \\in J^{\\prime} .$$The new dual is feasible, by our choice of $\\alpha$. Lemma 2 says that the dual objective strictly increases, and we used this to derive the fact that the algorithm is finite.\nLemma 2: “The total amount subtracted from the entries in the matrix strictly increases.”\nProof. We subtract $\\alpha$ from $n\\left(n-\\left|I^{\\prime}\\right|\\right)$ entries, and we add $\\alpha$ to $n\\left(\\left|J^{\\prime}\\right|\\right)$ entries. Hence in total we subtracted $\\alpha n\\left(n-\\left|I^{\\prime}\\right|-\\left|J^{\\prime}\\right|\\right)$. Now, note that $\\left|I^{\\prime}\\right|+\\left|J^{\\prime}\\right|$ is equal to the size of the vertex cover, which is strictly less than $n$.\nKőnig’s theorem: In any bipartite graph, the number of edges in a maximum matching equals the number of vertices in a minimum vertex cover\nHow to uncover vertex cover from maximal match. Wiki This is what is known as a primal-dual algorithm.\nSolving the KKT Conditions $$\\begin{array}{ll} \\min \u0026 \\sum_{i \\in I} \\sum_{j \\in J} c_{i j} x_{i j} \\\\ \\text { s.t. } \u0026 \\sum_{j \\in J} x_{i j}=1 \\text { for all } i \\in I \\\\ \u0026 \\sum_{i \\in I} x_{i j}=1 \\text { for all } j \\in J \\\\ \u0026 x_{i j} \\geq 0 \\end{array}$$The Lagrangian\n$$\\begin{aligned} L(\\mathbf{x}, \\mathbf{u}, \\mathbf{z}, \\mathbf{v}) \u0026= \\sum_{i,j}c_{i,j}x_{i,j}+\\sum_{i}u_i(\\sum_j x_{i,j}-1) + \\sum_{j} v_j(\\sum_jx_{i,j}-1) - \\sum_{i,j} z_{i,j} x_{i,j} \\\\ \u0026= \\sum_{i,j}(c_{i,j} + u_i + v_j-z_{i,j})x_{i,j} - \\sum_i u_i - \\sum_j v_j \\end{aligned} $$The KKT conditions are\n$$ \\begin{cases} \\sum_i x_{i,j} = 1, \\\\ \\sum_j x_{i,j} = 1, \\\\ x_{i,j} \\ge 0, \\\\ z_{i,j} \\ge 0, \\\\ z_{i,j}x_{i,j}=0, \\\\ c_{i,j}+u_i + v_j -z_{i,j}=0 \\end{cases}$$$$\\Longrightarrow$$$$\\begin{cases} \\sum_i x_{i,j} =1, \\\\ \\sum_j x_{i,j} =1, \\\\ x_{i,j} \\ge 0, \\\\ c_{i,j} - u_i - v_j \\ge 0, \\\\ \\left(c_{i,j} - u_i - v_j \\right) x_{i,j} =0 \\end{cases}$$The second to the last equality on the left (or the last equality on the right) is called the slackness condition.\nGated Hungarian Match The complexity of the Hungarian algorithm is $\\mathcal{O}(n^3)$, which is quite high. However, if the bipartite map can be splited into disconnected smaller graphs, we can dramatically reduce the computational cost.\nAlgorithm Given the cost matrix, $\\mathbf{C} \\in \\mathbb{R}^{m \\times n}$. Construct the adjacent list, $\\mathbf{L}=\\{\\mathbf{l}_1, \\mathbf {l}_2, \\dots, \\mathbf{l}_{m+n}\\}$, where each list, $\\mathbf{l}_i$, contains its adjacent nodes. (based on reference [3])\nstd::vector\u003cstd::vector\u003cint\u003e\u003e nb_graph; nb_graph.resize(rows_num_ + cols_num_); for (size_t i = 0; i \u003c rows_num_; ++i) { for (size_t j = 0; j \u003c cols_num_; ++j) { if (is_valid_cost_(global_costs_(i, j))) { nb_graph[i].push_back(static_cast\u003cint\u003e(rows_num_) + j); nb_graph[j + rows_num_].push_back(i); } } } Once the adjacent list is constructed, we need to find its connected components. Here, each component records the connected node numbers. Here we use the breadth-first search. int num_item = static_cast\u003cint\u003e(graph.size()); std::vector\u003cint\u003e visited; visited.resize(num_item, 0); std::queue\u003cint\u003e que; std::vector\u003cint\u003e component; component.reserve(num_item); components-\u003eclear(); for (int index = 0; index \u003c num_item; ++index) { if (visited[index]) { continue; } component.push_back(index); que.push(index); visited[index] = 1; while (!que.empty()) { int current_id = que.front(); que.pop(); for (size_t sub_index = 0; sub_index \u003c graph[current_id].size(); ++sub_index) { int neighbor_id = graph[current_id][sub_index]; if (visited[neighbor_id] == 0) { component.push_back(neighbor_id); que.push(neighbor_id); visited[neighbor_id] = 1; } } } components-\u003epush_back(component); component.clear(); Use row_component and col_component to distinguish node types of the bipartite graph in each component. std::vector\u003cstd::vector\u003cint\u003e\u003e components; ConnectedComponentAnalysis(nb_graph, \u0026components); row_components-\u003eclear(); row_components-\u003eresize(components.size()); col_components-\u003eclear(); col_components-\u003eresize(components.size()); for (size_t i = 0; i \u003c components.size(); ++i) { for (size_t j = 0; j \u003c components[i].size(); ++j) { int id = components[i][j]; if (id \u003c static_cast\u003cint\u003e(rows_num_)) { row_components-\u003eat(i).push_back(id); } else { id -= static_cast\u003cint\u003e(rows_num_); col_components-\u003eat(i).push_back(id); } } } Find the cost matrix for each connected component and use the rectangular Hungarian method to find the assignment solution.\nGated Hungarian, Hungarian with a Gated Cost Matrix, and Hungarian Hungarian method with gated cost matrix: set the values in the cost matrix larger than a threshold to be the maximal allowable values. When some of the values are set to be the largest values, the Hungarian matrix will converge faster. At each step, the Hungarian algorithm will check the distance between primal and dual, and the gated cost matrix results in a faster finding of the global value. (The algorithm will find the smallest of each row and column at each step. When its smallest reaches the threshold, the algorithm will terminate. So, setting the values above the threshold will accelerate computation.)\nComputational Time Experiments The cost matrix $C \\in [0, 1]^{300 \\times 300}$, with increasing threshold, at each threshold, repeats experiments 10 times.\na. do not set values larger than the threshold\nb. set values larger than a threshold as the threshold\n$C \\in [0, 1]^{30 \\times 30}$ , randomly generate cost matrix 100 times and average the values\na. do not set values larger than the threshold\nb. set values larger than the threshold as the threshold\nSummary To use the Hungarian algorithm, the best practice is thresholding the cost matrix before feeding it to the algorithm. When the cost matrix can be decomposed into more than or equal to two disconnected components, we’d better use the gate Hungarian algorithm.\nObjective Values Hungarian and Hungarian with gated cost matrices will result in different solutions. The gate Hungarian algorithm and the Hungarian algorithm with a gated cost matrix will lead to the same solution. For the objective value, the overall cost of Hungarian with pruning values that are larger than the threshold does not always lead to a smaller value compared with gated Hungarian method. For example, when the cost matrix is\n$$C = \\begin{bmatrix} 0.100973\u0026 0.154588\u0026 0.00125754 \\\\ 0.904433\u0026 0.728045\u0026 0.596809 \\\\ 0.296041\u0026 0.462023\u0026 0.0037384 \\end{bmatrix} $$with threshold=0.007. The Hungarian method results in assignments (0,0), (1,1), (2,2), and after pruning values that are larger than the threshold, we have cost=0.003. The gated Hungarian leads to assignments (0, 3) with cost=0.0012. References [1] J. Bijsterbosch and A. Volgenant, “Solving the Rectangular assignment problem and applications,” Ann Oper Res, vol. 181, no. 1, pp. 443–462, Dec. 2010, doi: 10.1007/s10479-010-0757-3.\n[2] D. F. Crouse, “On implementing 2D rectangular assignment algorithms,” IEEE Transactions on Aerospace and Electronic Systems, vol. 52, no. 4, pp. 1679–1696, Aug. 2016, doi: 10.1109/TAES.2016.140952.\n[3] Gated Hungarian Match (github Apollo C++ code)\n[4] lec11.pdf\n[5] github C++ code\n","wordCount":"1481","inLanguage":"en","image":"https://livey.github.io/posts/2024-11-assignment/%3Cimage%20path/url%3E","datePublished":"2024-11-20T00:00:00Z","dateModified":"2024-11-20T00:00:00Z","author":{"@type":"Person","name":"Fuwei Li"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://livey.github.io/posts/2024-11-assignment/"},"publisher":{"@type":"Organization","name":"Fuwei's Tech Notes","logo":{"@type":"ImageObject","url":"https://livey.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://livey.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://livey.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://livey.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://livey.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://livey.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://livey.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://livey.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://livey.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">The Assignment Problem and Primal-Dual Algorithm</h1><div class=post-description>Hungarian algorithm, prime-dual interpretation, and the gated Hungarian algorithm</div><div class=post-meta><span title='2024-11-20 00:00:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1481 words&nbsp;·&nbsp;Fuwei Li&nbsp;|&nbsp;<a href=https://github.com/livey/livey.github.io/issues/new rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#tutor aria-label=Tutor>Tutor</a></li><li><a href=#prime-dual-interpretation-of-hungarian-algorithm aria-label="Prime-Dual Interpretation of Hungarian Algorithm">Prime-Dual Interpretation of Hungarian Algorithm</a></li><li><a href=#solving-the-kkt-conditions aria-label="Solving the KKT Conditions">Solving the KKT Conditions</a></li><li><a href=#gated-hungarian-match aria-label="Gated Hungarian Match">Gated Hungarian Match</a><ul><li><a href=#algorithm aria-label=Algorithm>Algorithm</a></li></ul></li><li><a href=#gated-hungarian-hungarian-with-a-gated-cost-matrix-and-hungarian aria-label="Gated Hungarian, Hungarian with a Gated Cost Matrix, and Hungarian">Gated Hungarian, Hungarian with a Gated Cost Matrix, and Hungarian</a><ul><li><a href=#computational-time-experiments aria-label="Computational Time Experiments">Computational Time Experiments</a></li><li><a href=#summary aria-label=Summary>Summary</a></li><li><a href=#objective-values aria-label="Objective Values">Objective Values</a></li></ul></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>This post discusses the assignment problem, its primal-dual interpretation, and the gated Hungarian algorithm.</p><h1 id=tutor>Tutor<a hidden class=anchor aria-hidden=true href=#tutor>#</a></h1><p><a href=https://brilliant.org/wiki/hungarian-matching/>HungarianAlgorithm</a> and [4] gives a nice interpretation of the dual-prime of the Hungarian algorithm.</p><h1 id=prime-dual-interpretation-of-hungarian-algorithm>Prime-Dual Interpretation of Hungarian Algorithm<a hidden class=anchor aria-hidden=true href=#prime-dual-interpretation-of-hungarian-algorithm>#</a></h1><p>The following linear program gives a lower bound on the optimal value of the assignment problem:</p>$$\begin{array}{ll}
\min & \sum_{i \in I} \sum_{j \in J} c_{i j} x_{i j} \\
\text { s.t. } & \sum_{j \in J} x_{i j}=1 \text { for all } i \in I \\
& \sum_{i \in I} x_{i j}=1 \text { for all } j \in J \\
& x_{i j} \geq 0
\end{array}$$<p>To see this, note that we can let $x_{i j}=1$ if $i$ is assigned to $j$ and 0 otherwise. Clearly, this is a feasible solution to the L.P, so the optimal value of the LP must be at most the optimal value of the assignment problem.</p><p>We consider the dual of the L.P:</p>$$\begin{array}{ll}
\max & \sum_{i \in I} u_i+\sum_{j \in J} v_j \\
\text { s.t. } & u_i+v_j \leq c_{i j} \text { for all } i \in I, j \in J
\end{array}$$<p>Now, we know that $x$ is an optimal solution to the primal L.P and $u, v$ is an optimal solution to the dual LP if and only if (i) $x$ is feasible for the primal LP, (ii) $u, v$ is feasible for the dual LP, (iii) the primal and dual solutions obey complementary slackness.</p><p>Thinking about what these conditions mean for the assignment problem allows us to formulate the Hungarian algorithm in a much more general way:</p><ol><li><p>We maintain a feasible dual solution. We let $u_i$ be the amount subtracted from row $i$ and $v_j$ is the amount subtracted from column $j$. Feasibility means that we must ensure that $\bar{c}_{i j}=c_{i j}-u_i-v_j$ is non-negative for all $(i, j)$.</p></li><li><p>We try to find a primal solution $x$ that satisfies complementary slackness with respect to the current dual solution. Complementary slackness for the assignment problem means that we try to find an assignment that only uses edges with $\bar{c}_{i j}=0$, i.e., we solve the maximum cardinality bipartite matching problem on the graph that contains a node for every $i \in I, j \in J$ and an edge $(i, j)$ if $\bar{c}_{i j}=0$. We either find a perfect matching, or we get a vertex cover of size $ < n$.</p></li></ol><ol start=3><li>If we can not find such a primal solution, we find a direction of dual increase. The vertex cover in the bipartite matching instance corresponds to $I^{\prime}, J^{\prime}$, a subset of the rows and columns, such that $\left|I^{\prime}\right|+\left|J^{\prime}\right| < n$ and if $\bar{c}_{ij}=0$ then $i \in I^{\prime}$ or $j \in J^{\prime}$.</li></ol><p>We let $\alpha = \min_{(i,j): i\notin I^\prime, j\notin J^\prime} \bar{c}_{i,j}$, and we update</p>$$u_i \leftarrow u_i-\alpha \text { for all } i \notin I^{\prime}, \quad v_j \leftarrow v_j+\alpha \text { for all } j \in J^{\prime} .$$<p>The new dual is feasible, by our choice of $\alpha$. Lemma 2 says that the dual objective strictly increases, and we used this to derive the fact that the algorithm is finite.</p><blockquote><p>Lemma 2: &ldquo;The total amount subtracted from the entries in the matrix strictly increases.&rdquo;</p><p>Proof. We subtract $\alpha$ from $n\left(n-\left|I^{\prime}\right|\right)$ entries, and we add $\alpha$ to $n\left(\left|J^{\prime}\right|\right)$ entries. Hence in total we subtracted $\alpha n\left(n-\left|I^{\prime}\right|-\left|J^{\prime}\right|\right)$. Now, note that $\left|I^{\prime}\right|+\left|J^{\prime}\right|$ is equal to the size of the vertex cover, which is strictly less than $n$.</p></blockquote><blockquote><p><em><a href="https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory)#:~:text=In%20any%20bipartite%20graph%2C%20the%20number%20of%20edges%20in%20a,in%20a%20minimum%20vertex%20cover."><strong>Kőnig&rsquo;s theorem</strong></a>: In any <a href=https://en.wikipedia.org/wiki/Bipartite_graph>bipartite graph</a>, the number of edges in a <a href=https://en.wikipedia.org/wiki/Maximum_matching>maximum matching</a> equals the number of vertices in a <a href=https://en.wikipedia.org/wiki/Minimum_vertex_cover>minimum vertex cover</a></em></p></blockquote><blockquote><p><a href=https://math.stackexchange.com/questions/3044261/how-to-find-a-minumum-vertex-cover-from-a-maximum-matching-in-a-bipartite-graph>How to uncover vertex cover from maximal match. </a><a href="https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory)#:~:text=.%5B4%5D-,Constructive%20proof%20without%20flow%20concepts,-%5Bedit%5D">Wiki</a></p></blockquote><p>This is what is known as a primal-dual algorithm.</p><h1 id=solving-the-kkt-conditions>Solving the KKT Conditions<a hidden class=anchor aria-hidden=true href=#solving-the-kkt-conditions>#</a></h1>$$\begin{array}{ll}
\min & \sum_{i \in I} \sum_{j \in J} c_{i j} x_{i j} \\
\text { s.t. } & \sum_{j \in J} x_{i j}=1 \text { for all } i \in I \\
& \sum_{i \in I} x_{i j}=1 \text { for all } j \in J \\
& x_{i j} \geq 0
\end{array}$$<p>The Lagrangian</p>$$\begin{aligned}
L(\mathbf{x}, \mathbf{u}, \mathbf{z}, \mathbf{v}) 
&= \sum_{i,j}c_{i,j}x_{i,j}+\sum_{i}u_i(\sum_j x_{i,j}-1) + \sum_{j} v_j(\sum_jx_{i,j}-1) - \sum_{i,j} z_{i,j} x_{i,j} \\
&= \sum_{i,j}(c_{i,j} + u_i + v_j-z_{i,j})x_{i,j} - \sum_i u_i - \sum_j v_j
\end{aligned}
$$<p>The KKT conditions are</p>$$
\begin{cases}
\sum_i x_{i,j} = 1, \\
\sum_j x_{i,j} = 1, \\
x_{i,j} \ge 0, \\
z_{i,j} \ge 0, \\
z_{i,j}x_{i,j}=0, \\
c_{i,j}+u_i + v_j -z_{i,j}=0
\end{cases}$$$$\Longrightarrow$$$$\begin{cases}
\sum_i x_{i,j} =1, \\
\sum_j x_{i,j} =1, \\
x_{i,j} \ge 0, \\
c_{i,j} - u_i - v_j \ge 0, \\
\left(c_{i,j} - u_i - v_j \right) x_{i,j} =0
\end{cases}$$<p>The second to the last equality on the left (or the last equality on the right) is called the slackness condition.</p><h1 id=gated-hungarian-match>Gated Hungarian Match<a hidden class=anchor aria-hidden=true href=#gated-hungarian-match>#</a></h1><p>The complexity of the Hungarian algorithm is $\mathcal{O}(n^3)$, which is quite high. However, if the bipartite map can be splited into disconnected smaller graphs, we can dramatically reduce the computational cost.</p><h2 id=algorithm>Algorithm<a hidden class=anchor aria-hidden=true href=#algorithm>#</a></h2><p>Given the cost matrix, $\mathbf{C} \in \mathbb{R}^{m \times n}$. Construct the adjacent list, $\mathbf{L}=\{\mathbf{l}_1, \mathbf {l}_2, \dots, \mathbf{l}_{m+n}\}$, where each list, $\mathbf{l}_i$, contains its adjacent nodes. (based on reference [3])</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>nb_graph</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>nb_graph</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>rows_num_</span> <span class=o>+</span> <span class=n>cols_num_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>rows_num_</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>cols_num_</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>is_valid_cost_</span><span class=p>(</span><span class=n>global_costs_</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>nb_graph</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>push_back</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>rows_num_</span><span class=p>)</span> <span class=o>+</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>nb_graph</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=n>rows_num_</span><span class=p>].</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>Once the adjacent list is constructed, we need to find its connected components. Here, each component records the connected node numbers. Here we use the breadth-first search.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>num_item</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>graph</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>visited</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>visited</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>num_item</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>queue</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>que</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>component</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>component</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=n>num_item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>components</span><span class=o>-&gt;</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>index</span> <span class=o>&lt;</span> <span class=n>num_item</span><span class=p>;</span> <span class=o>++</span><span class=n>index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>visited</span><span class=p>[</span><span class=n>index</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>component</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>que</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>que</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>current_id</span> <span class=o>=</span> <span class=n>que</span><span class=p>.</span><span class=n>front</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>que</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>sub_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>sub_index</span> <span class=o>&lt;</span> <span class=n>graph</span><span class=p>[</span><span class=n>current_id</span><span class=p>].</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>           <span class=o>++</span><span class=n>sub_index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>neighbor_id</span> <span class=o>=</span> <span class=n>graph</span><span class=p>[</span><span class=n>current_id</span><span class=p>][</span><span class=n>sub_index</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>visited</span><span class=p>[</span><span class=n>neighbor_id</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>component</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>neighbor_id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>que</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>neighbor_id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>visited</span><span class=p>[</span><span class=n>neighbor_id</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>components</span><span class=o>-&gt;</span><span class=n>push_back</span><span class=p>(</span><span class=n>component</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>component</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span></code></pre></div><p>Use row_component and col_component to distinguish node types of the bipartite graph in each component.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>components</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ConnectedComponentAnalysis</span><span class=p>(</span><span class=n>nb_graph</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>components</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>row_components</span><span class=o>-&gt;</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>row_components</span><span class=o>-&gt;</span><span class=n>resize</span><span class=p>(</span><span class=n>components</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>col_components</span><span class=o>-&gt;</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>col_components</span><span class=o>-&gt;</span><span class=n>resize</span><span class=p>(</span><span class=n>components</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>components</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>components</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>id</span> <span class=o>=</span> <span class=n>components</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>id</span> <span class=o>&lt;</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>rows_num_</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>row_components</span><span class=o>-&gt;</span><span class=n>at</span><span class=p>(</span><span class=n>i</span><span class=p>).</span><span class=n>push_back</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>id</span> <span class=o>-=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>rows_num_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>col_components</span><span class=o>-&gt;</span><span class=n>at</span><span class=p>(</span><span class=n>i</span><span class=p>).</span><span class=n>push_back</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>Find the cost matrix for each connected component and use the rectangular Hungarian method to find the assignment solution.</p><h1 id=gated-hungarian-hungarian-with-a-gated-cost-matrix-and-hungarian>Gated Hungarian, Hungarian with a Gated Cost Matrix, and Hungarian<a hidden class=anchor aria-hidden=true href=#gated-hungarian-hungarian-with-a-gated-cost-matrix-and-hungarian>#</a></h1><p>Hungarian method with gated cost matrix: set the values in the cost matrix larger than a threshold to be the maximal allowable values. When some of the values are set to be the largest values, the Hungarian matrix will converge faster. At each step, the Hungarian algorithm will check the distance between primal and dual, and the gated cost matrix results in a faster finding of the global value. (The algorithm will find the smallest of each row and column at each step. When its smallest reaches the threshold, the algorithm will terminate. So, setting the values above the threshold will accelerate computation.)</p><h2 id=computational-time-experiments>Computational Time Experiments<a hidden class=anchor aria-hidden=true href=#computational-time-experiments>#</a></h2><ol><li><p>The cost matrix $C \in [0, 1]^{300 \times 300}$, with increasing threshold, at each threshold, repeats experiments 10 times.</p><p>a. do not set values larger than the threshold</p><div style="text-align:center;margin:0 auto;display:flex;justify-content:center"><img src=./resources/do-not-set-largest-value.png alt="Do not set largest value" style=width:70%></div><p>b. set values larger than a threshold as the threshold</p><div style="text-align:center;margin:0 auto;display:flex;justify-content:center"><img src=./resources/set-largest-th-value.png alt="Set largest value as threshold" style=width:70%></div></li><li><p>$C \in [0, 1]^{30 \times 30}$ , randomly generate cost matrix 100 times and average the values</p><p>a. do not set values larger than the threshold</p><div style="text-align:center;margin:0 auto;display:flex;justify-content:center"><img src=./resources/do-not-set-small.png alt="Do not set largest value" style=width:70%></div><p>b. set values larger than the threshold as the threshold</p><div style="text-align:center;margin:0 auto;display:flex;justify-content:center"><img src=./resources/set-small.png alt="Set largest value as threshold" style=width:70%></div></li></ol><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>To use the Hungarian algorithm, the best practice is thresholding the cost matrix before feeding it to the algorithm. When the cost matrix can be decomposed into more than or equal to two disconnected components, we&rsquo;d better use the gate Hungarian algorithm.</p><h2 id=objective-values>Objective Values<a hidden class=anchor aria-hidden=true href=#objective-values>#</a></h2><p>Hungarian and Hungarian with gated cost matrices will result in different solutions. The gate Hungarian algorithm and the Hungarian algorithm with a gated cost matrix will lead to the same solution. For the objective value, the overall cost of Hungarian with pruning values that are larger than the threshold does not always lead to a smaller value compared with gated Hungarian method. For example, when the cost matrix is</p>$$C =
\begin{bmatrix}
0.100973& 0.154588& 0.00125754 \\ 0.904433& 0.728045& 0.596809 \\
0.296041& 0.462023& 0.0037384
\end{bmatrix}
$$<p>with threshold=0.007. The Hungarian method results in assignments (0,0), (1,1), (2,2), and after pruning values that are larger than the threshold, we have cost=0.003. The gated Hungarian leads to assignments (0, 3) with cost=0.0012.</p><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><p>[1] J. Bijsterbosch and A. Volgenant, &ldquo;Solving the Rectangular assignment problem and applications,&rdquo; Ann Oper Res, vol. 181, no. 1, pp. 443–462, Dec. 2010, doi: 10.1007/s10479-010-0757-3.</p><p>[2] D. F. Crouse, &ldquo;On implementing 2D rectangular assignment algorithms,&rdquo; IEEE Transactions on Aerospace and Electronic Systems, vol. 52, no. 4, pp. 1679–1696, Aug. 2016, doi: 10.1109/TAES.2016.140952.</p><p>[3] <a href=https://github.com/ApolloAuto/apollo/blob/master/modules/perception/common/graph/gated_hungarian_bigraph_matcher.h>Gated Hungarian Match (github Apollo C++ code)</a></p><p>[4] <a href=https://resources.mpi-inf.mpg.de/departments/d1/teaching/ss11/OPT/lec11.pdf>lec11.pdf</a></p><p>[5] <a href=https://github.com/mcximing/hungarian-algorithm-cpp>github C++ code</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://livey.github.io/tags/assignment-problem/>Assignment Problem</a></li><li><a href=https://livey.github.io/tags/signal-processing/>Signal Processing</a></li><li><a href=https://livey.github.io/tags/optimization/>Optimization</a></li><li><a href=https://livey.github.io/tags/hungarian-algorithm/>Hungarian Algorithm</a></li><li><a href=https://livey.github.io/tags/primal-dual-algorithm/>Primal-Dual Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://livey.github.io/posts/2024-12-camera-frustum/><span class=title>« Prev</span><br><span>Camera Projection via View Frustum Culling</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share The Assignment Problem and Primal-Dual Algorithm on x" href="https://x.com/intent/tweet/?text=The%20Assignment%20Problem%20and%20Primal-Dual%20Algorithm&amp;url=https%3a%2f%2flivey.github.io%2fposts%2f2024-11-assignment%2f&amp;hashtags=AssignmentProblem%2cSignalProcessing%2cOptimization%2cHungarianAlgorithm%2cPrimal-DualAlgorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Assignment Problem and Primal-Dual Algorithm on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flivey.github.io%2fposts%2f2024-11-assignment%2f&amp;title=The%20Assignment%20Problem%20and%20Primal-Dual%20Algorithm&amp;summary=The%20Assignment%20Problem%20and%20Primal-Dual%20Algorithm&amp;source=https%3a%2f%2flivey.github.io%2fposts%2f2024-11-assignment%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Assignment Problem and Primal-Dual Algorithm on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flivey.github.io%2fposts%2f2024-11-assignment%2f&title=The%20Assignment%20Problem%20and%20Primal-Dual%20Algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Assignment Problem and Primal-Dual Algorithm on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flivey.github.io%2fposts%2f2024-11-assignment%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Assignment Problem and Primal-Dual Algorithm on whatsapp" href="https://api.whatsapp.com/send?text=The%20Assignment%20Problem%20and%20Primal-Dual%20Algorithm%20-%20https%3a%2f%2flivey.github.io%2fposts%2f2024-11-assignment%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Assignment Problem and Primal-Dual Algorithm on telegram" href="https://telegram.me/share/url?text=The%20Assignment%20Problem%20and%20Primal-Dual%20Algorithm&amp;url=https%3a%2f%2flivey.github.io%2fposts%2f2024-11-assignment%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Assignment Problem and Primal-Dual Algorithm on ycombinator" href="https://news.ycombinator.com/submitlink?t=The%20Assignment%20Problem%20and%20Primal-Dual%20Algorithm&u=https%3a%2f%2flivey.github.io%2fposts%2f2024-11-assignment%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://livey.github.io/>Fuwei's Tech Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Path Generating | Fuwei's Tech Notes</title>
<meta name=keywords content="Path Generating,Annotation,Path Planning,Motion Planning,Autonomous Driving"><meta name=description content="Generating a natural path to connect two given points."><meta name=author content="Fuwei Li"><link rel=canonical href=https://livey.github.io><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://livey.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://livey.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://livey.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://livey.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://livey.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://livey.github.io/posts/2025-04-16-path-genrating/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="index, follow"><meta name=author content="Fuwei Li"><meta name=description content="Generating a natural path to connect two given points."><meta property="og:type" content="article"><meta property="og:url" content="https://livey.github.io/posts/2025-04-16-path-genrating/"><meta property="og:title" content="Path Generating"><meta property="og:description" content="Generating a natural path to connect two given points."><meta property="og:image" content="https://livey.github.io/images/site-preview.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Path Generating"><meta name=twitter:description content="Generating a natural path to connect two given points."><meta name=twitter:image content="https://livey.github.io/images/site-preview.jpg"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://livey.github.io/posts/2025-04-16-path-genrating/"><meta property="og:site_name" content="Fuwei's Tech Notes"><meta property="og:title" content="Path Generating"><meta property="og:description" content="Generating a natural path to connect two given points."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-16T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-16T00:00:00+00:00"><meta property="article:tag" content="Path Generating"><meta property="article:tag" content="Annotation"><meta property="article:tag" content="Path Planning"><meta property="article:tag" content="Motion Planning"><meta property="article:tag" content="Autonomous Driving"><meta property="og:image" content="https://livey.github.io/posts/2025-04-16-path-genrating/%3Cimage%20path/url%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://livey.github.io/posts/2025-04-16-path-genrating/%3Cimage%20path/url%3E"><meta name=twitter:title content="Path Generating"><meta name=twitter:description content="Generating a natural path to connect two given points."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://livey.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Path Generating","item":"https://livey.github.io/posts/2025-04-16-path-genrating/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Path Generating","name":"Path Generating","description":"Generating a natural path to connect two given points.","keywords":["Path Generating","Annotation","Path Planning","Motion Planning","Autonomous Driving"],"articleBody":"Given a starting point, starting direction, ending point, and ending direction, the goal is to generate a feasible and “natural” path that connects the two points. This path should adhere to vehicle dynamics and avoids obstacles. However, it is hard to define what is “natural”.\nPath Planning In this section, we review some classical path planning methods. We ignore the algorithmic details and focus on the resulting path shapes to provide an overview. The demonstration images are generated using the code repository [1].\nClassical Paths A Star and Bidirectional A Star Left: A* search. Right: bidirectional A* search. Depth First Search, Bezier Path, and Model Predictive Trajectory Left: depth first search. Middle: Bezier path. Right: model predictive trajectory. Voronoi Road Map and Visibility Road Map Left: Voronoi road map. Middle: Voronoi fails in open space. Right: visibility road map. Quartic Bezier Spline We find that the quartic Bezier spline works well for scenarios involving right turns, U-turns, and lane changes [5].\nA quartic Bezier spline is defined by five control points, $\\mathbf p_0, \\mathbf p_1, \\mathbf p_2, \\mathbf p_3, \\mathbf p_4$, with parameters $t \\in [0, 1]$, and is given by\n$$B(t) = \\sum_{i=0}^{4} \\binom{4}{i}\\, t^i\\,(1 - t)^{4-i} \\mathbf{p}_i. $$When $t = 0$, $B(0) = \\mathbf{p}_0$ and $t = 1$, $B(1) = \\mathbf{p}_4$. Then, $\\mathbf{p}_0$ and $\\mathbf{p}_4$ are the start and end points, respectively.\nLet us define $B_{i,n}(t)=\\binom{n}{i}\\, t^i\\,(1 - t)^{n-i}$. Then, the quartic Bezier spline can be rewritten as:\n$$ B(t) = \\sum_{i=0}^4 B_{i,4}(t) \\mathbf{p}_i. $$To compute the derivative of the quartic Bezier spline, let us first compute the derivative of $B_{i,n}(t)$:\n$$ \\frac{d}{dt}B_{i,n}(t) = n \\left(B_{i-1,n-1}(t) - B_{i,n-1}(t)\\right). $$Then the derivative of the quartic Bezier spline is:\n$$ \\begin{aligned} B^\\prime(t) \u0026= 4 \\sum_{i=1}^4 B_{i-1, 3}(t)\\mathbf{p}_{i} - 4 \\sum_{i=0}^3 B_{i, 3}(t)\\mathbf{p}_{i} \\\\ \u0026= 4 \\sum_{i=0}^3 B_{i, 3}(t)\\left(\\mathbf{p}_{i+1} - \\mathbf{p}_{i}\\right). \\end{aligned} $$Observing that\n$$ B^\\prime(0) = 4 \\sum_{i=0}^3 B_{i, 3}(0)\\left(\\mathbf{p}_{i+1} - \\mathbf{p}_{i}\\right) = 4 \\left(\\mathbf{p}_1 - \\mathbf{p}_0\\right), $$$$ B^\\prime(1) = 4 \\sum_{i=0}^3 B_{i, 3}(1)\\left(\\mathbf{p}_{i+1} - \\mathbf{p}_{i}\\right) = 4 \\left(\\mathbf{p}_4 - \\mathbf{p}_3\\right). $$Smoothness Constraint Suppose the start unit direction is $\\mathbf{d}_0$ and the end unit direction is $\\mathbf{d}_4$. To ensure the path curve is smooth at the start and end points, we constrain the path’s first derivative to match the given directions. So, we have $\\mathbf{d}_0 \\propto \\mathbf{p}_1 - \\mathbf{p}_0$ and $\\mathbf{d}_4 \\propto \\mathbf{p}_4 - \\mathbf{p}_3$. Then, the control points $\\mathbf{p}_1$ and $\\mathbf{p}_3$ are along the start and end directions, respectively,\n$$\\mathbf{p}_1 = \\mathbf{p}_0 + \\alpha \\mathbf{d}_0, \\quad \\mathbf{p}_3 = \\mathbf{p}_4 - \\beta \\mathbf{d}_4,$$where $\\alpha$ and $\\beta$ are positive scalars.\nExperiments In this experiment, we impose derivative constraints only at the start and end points and explore the resulting path shapes.\nWe make the starting points at $(0, 0)$ with normalized direction $(1,0)$ We test right turn, U-turn, and lane change, with ending points and directions pairs $[(15, -9), (0, -1)], [(0, 10), (-1, 0)], [(13, 2), (1, 0)]$, respectively.\nFirst column: Right turn; Second column: U-turn; Third column: Lane change. Two rows represent different control points. Minimum Variation of Curvature Defining a “natural” path presents another challenge. The first idea is the model predictive trajectory. However, model predictive trajectory relies on a reference trajectory, which is also difficult to define. After reviewing relevant research, especially regarding model predictive references (e.g., [2,4]), we employ the minimum variation of curvature as our objective to fulfill our requirements. The variation of the curvature is defined as:\n$$ V=\\int_0^1\\left(\\frac{d\\kappa(t)}{dt}\\right)^2\\,dt, $$where $\\kappa(t)$ is the curvature of the path at $t$ and can be computed by:\n$$ \\kappa(t) = \\frac{\\|B^\\prime(t)\\times B^{\\prime \\prime}(t)\\|}{\\|B^\\prime(t)\\|^3}, $$where the second derivative of the quartic Bezier curve is:\n$$ B^{\\prime \\prime}(t) = 12 \\sum_{i=0}^{2} B_{i,2}(t)(\\mathbf{p}_{i+2} - 2\\mathbf{p}_{i+1} + \\mathbf{p}_i). $$Further, we only put maximal curvature constraint as a simplified representation of vehicle dynamic constraints. Meanwhile, we add the distance to obstacles as a hard constraint.\nIn summary, our optimization problem’s objective is to minimize the variation of the curvature:\n$$ \\min_{\\alpha, \\beta, \\lambda} \\int_0^1\\left(\\frac{d\\kappa(t)}{dt}\\right)^2\\,dt, $$with constraints:\n1. The curve is smooth at the starting point, meaning the second control point lies along the initial direction:\n$$ \\mathbf p_1 = \\mathbf p_0 + \\alpha L \\mathbf d_0 $$the same constraint applies to the end point, leading to the fourth control point,\n$$ \\mathbf p_3 = \\mathbf p_4 - \\beta L \\mathbf d_4 $$where $0 \u003c \\alpha, \\beta \u003c 1$, where $L = \\|\\mathbf{p}_0 - \\mathbf{p}_4 \\|$ is the distance between the start and end points.\n2. To further simplify the optimization variables, we introduce an optional constraint where the third control point, $\\mathbf p_2$, lies on the line segment between $\\mathbf p_1$ and $\\mathbf p_3$:\n$$ \\mathbf p_2 = \\lambda \\mathbf p_1 + (1-\\lambda)\\mathbf p_3 $$where $0 \\le \\lambda \\le 1$. Depending on the complexity of the environment, this constraint is optional.\n3. Maximal curvature constraint\n$$ \\kappa(t) \\le \\kappa_{max} $$4. Distances to obstacles\n$$ d\\left(B(t), \\mathbf{M}_i\\right) \\ge r_i, \\text{ for all } i = 1, 2, \\cdots, M \\text{ and } t \\in [0, 1] $$where we model the $i$-th obstacle, $\\mathbf{M}_i$, as a circle with radius $r_i$.\nNumerical consideration The variation of curvature constraint is hard to implement directly. We use its numerical approximation:\n$$ \\frac{d\\kappa(t_i)}{dt}\\approx \\frac{\\kappa(t_i) - \\kappa(t_{i-1})}{\\Delta t} $$The curvature\n$$ \\begin{aligned} \\kappa(t) \u0026= \\frac{\\|B^\\prime(t)\\times B^{\\prime \\prime}(t)\\|}{\\|B^\\prime(t)\\|^3}\\\\ \u0026= \\frac{B_x^\\prime(t)B_Y^{\\prime \\prime} - B_y^\\prime(t)B_x^{\\prime \\prime(t)}}{(B_x^\\prime(t)^2 + B_y^\\prime(t)^2)^{3/2}} \\end{aligned} $$Algorithm The algorithm proceeds as follows:\nDivide parameter, $t$, space, $[0, 1]$, into $N$ equally spaced intervals, with $\\{t_i\\}_{i=0}^{N}$\nCompute $\\kappa(t_i)$, $\\frac{d\\kappa(t_i)}{dt}$, and total variation, $V$, numerically\nUse an optimization algorithm (e.g., Sequential Least-Squares Programming (SLSQP)) to solve the optimization problem.\nExperiments With and Without $\\mathbf p_2$ Constraint Constrained Unconstrained Comparison of generated paths. Left column: $\\mathbf{p}_2$ constrained. Right column: $\\mathbf{p}_2$ unconstrained.\nThe results indicate that the path generated without the $\\mathbf p_2$ constraint appears more natural.\nDifferent Curvature Constraints Left: Max curvature 1/6.0 (failed). Right: Max curvature 1/3.0 (successful). Failure Case Applying non-judiciously chosen initial variables can result in failure.\nLeft: Failure occurs due to a poor initial guess. Right: Increasing the number of sampling points can also lead to failure. Specialized $\\mathbf{p}_2$ initialization Paths generated using specialized P2 initialization for various scenarios and obstacle configurations. Summary To accelerate the optimization, we incrementally add constraints, starting from the simplest, to find a feasible solution.\nThe optimization variables sets are:\n$\\alpha, \\beta, \\lambda$ $\\alpha, \\beta, \\mathbf{p}_2$ The constraint sets considered are:\nNo direct constraints Maximal curvature Obstacle avoidance Our workflow is illustrated below: where $O_i$ and $C_{j}$, denote the $(i)$th and $(j)$th objective and constraint, respectively.\nSome examples are shown below:\nPaths generated with different obstacle radii and optimization settings. Top-left: r=1, O1. Top-right: r=2, O1+C2+C3. Bottom-left: r=3, O2+C2+C3. Bottom-right: r=4, O2+C2+C3. Appendix Ego vehicle dynamics This work utilizes a kinematic bicycle model. The vehicle state is represented by:\n$$ X = [x \\, y \\, v \\, \\theta] $$where $x$, $y$ is the 2D position of the vehicle, $v$ is the vehicle speed, and $\\theta$ is the vehicle’s yaw. The vehicle dynamics are described by:\n$$ \\dot{X} = \\begin{bmatrix} v \\cos \\theta \\\\ v \\sin \\theta \\\\ 0 \\\\ 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026 0 \\\\ 0 \u0026 0 \\\\ 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\dot{v} \\\\ \\dot{\\theta} \\end{bmatrix} $$As we are dealing in discrete time domain, the state update equation becomes:\n$$X_{k+1} = \\begin{bmatrix} x_{k+1} \\\\ y_{k+1} \\\\ v_{k+1} \\\\ \\theta_{k+1} \\end{bmatrix}^T = f(x_k, u_k)$$where\n$$x_{k+1} = x_k + \\cos\\theta_k \\left( v_k T_s + \\frac{\\dot{v}_k}{2} T_s^2 \\right)$$$$y_{k+1} = y_k + \\sin\\theta_k \\left( v_k T_s + \\frac{\\dot{v}_k}{2} T_s^2 \\right)$$and\n$$v_{k+1} = v_k + \\dot{v}_k T_s$$$$\\theta_{k+1} = \\theta_k + \\dot{\\theta}_k T_s$$State Cost End State Cost We aim for the terminal state to match a desired state,\n$$ \\mathbf{x}_e = [x_e, y_e, v_e, \\theta_e] $$So, the end state cost is\n$$ (\\mathbf{x}-\\mathbf{x}_e)^\\top\\Lambda (\\mathbf{x}-\\mathbf{x}_e) $$$$\\Lambda = \\text{diag}(\\lambda_x^e, \\lambda^e_y, 0, \\lambda_\\theta^e) $$Intermediate State Cost Acceleration\nYaw rate\nDesired velocity tracking\nConstraints The approximated object using ellipses and circles. Low and high acceleration bounds Low and high yaw rate bounds Obstacle constraints Obstacles are represented by points in the plane. So, for each obstacle point, $\\mathbf{x}^o_i$, we must have\n$$d(\\mathbf{x}, \\mathbf{x}^o_i) \u003e 0 $$Linear Quadratic Regulator Problem $$ \\begin{aligned} \\underset{x_1, \\dots,x_N, u_1,\\dots, u_N }{\\text{argmin}} \u0026\\quad \\frac{1}{2} x_N^T Q_N x_N + \\frac{1}{2} \\sum_{k=1}^{N-1} x_k^T Q_k x_k + u_k^T R_k u_k \\\\ s.t. \u0026\\quad x_{k+1} = A_k x_t + B_k u_k \\end{aligned} $$Here, the objective function is quadratic with respect to states and controls, and the system transition is linear.\nSolution This problem can be solved using dynamic programming. The solution reveals that the state value function is quadratic, and the optimal policy is linear with respect to the state.\nFirstly, the state value function $V(\\mathbf{x}_N)$ is known as\n$$V(\\mathbf{x}_N) = \\frac{1}{2}\\mathbf{x}_N^\\top\\mathbf{Q}_N\\mathbf{x}_N$$The state value function, $V(\\mathbf{x}_{N-1})$, can be computed by\n$$ V(\\mathbf{x}_{N-1}) = \\min_{\\mathbf{u}_{N-1}} \\frac{1}{2}\\mathbf{x}_{N-1}^\\top\\mathbf{Q}_{N-1}\\mathbf{x}_{N-1} + \\frac{1}{2}\\mathbf{u}_{N-1}\\mathbf{R}_{N-1}\\mathbf{u}_{N-1} + V(\\mathbf{x}_N) $$Observing that the function is quadratic with respect to $\\mathbf{u}_{N-1}$, taking gradient of the state function with respect to $\\mathbf{u}_{N-1}$ and set to zero we have\n$$ \\begin{aligned} u^*_{N-1} \u0026= -\\left( R_{N-1} + B_{N-1}^T S_N B_{N-1} \\right)^{-1} B_{N-1}^T S_N A_{N-1} x_{N-1} \\\\ \u0026\\equiv K_{N-1} x_{N-1} \\end{aligned} $$where we define $S_N = Q_N$, and the state value function is\n$$ \\begin{aligned} V_{N-1}(x_{N-1}) \u0026= \\frac{1}{2} x_{N-1}^T Q_{N-1} x_{N-1} + \\frac{1}{2} x_{N-1}^T K_{N-1}^T R_{N-1} K_{N-1} x_{N-1} \\\\ \u0026\\quad + \\frac{1}{2} \\left( A_{N-1} x_{N-1} + B_{N-1} K_{N-1} x_{N-1} \\right)^T P_N \\left( A_{N-1} x_{N-1} + B_{N-1} K_{N-1} x_{N-1} \\right) \\\\ \u0026= \\frac{1}{2} x_{N-1}^T \\left( Q_{N-1} + K_{N-1}^T R_{N-1} K_{N-1} + \\left( A_{N-1} + B_{N-1} K_{N-1} \\right)^T S_N \\left( A_{N-1} + B_{N-1} K_{N-1} \\right) \\right) x_{N-1} \\\\ \u0026\\equiv \\frac{1}{2} x_{N-1}^T S_N x_{N-1} \\end{aligned} $$Summary In the LQR, the objective is quadratic with respect to the state and control, and the optimal control is a linear function of the state.\nIterative Linear Quadratic Regulator Problem $$ \\begin{aligned} \\underset{\\mathbf{x}_1,\\dots,\\mathbf{x}_N, \\mathbf{u}_1,\\dots,\\mathbf{u}_N}{\\text{argmin}} \u0026\\quad \\ell({\\mathbf{x}_N})+ \\sum_{k=1}^{N-1}\\ell(\\mathbf{x}_k, \\mathbf{u}_k)\\\\ s.t. \u0026 \\quad \\mathbf{x}_{k+1} = f(\\mathbf{x}_k, \\mathbf{u}_k) \\end{aligned} $$where the objective function is twice differentiable and the system dynamic is differentiable.\nWe expand the cost function and system dynamic along a nominal trajectory.\nCost Function Many cost functions used in iLQR are quadratic. If the cost function is not quadratic, a second-order Taylor series expansion approximates it quadratically. Similarly, the dynamics are linearized using a first-order Taylor expansion. Note that constant terms in the cost expansion are dropped as they do not affect the minimization:\n$$ \\begin{aligned} J(x_0, U) \u0026= \\ell_f(x_N) + \\sum_{k=1}^{N-1} \\ell(x_k, u_k)\\\\ \u0026\\approx \\frac{1}{2} x_N^T Q_N x_N + q_N^T x_N + \\sum_{k=1}^{N-1} \\left( \\frac{1}{2} x_k^T Q_k x_k + \\frac{1}{2} u_k^T R_k u_k + \\frac{1}{2} x_k^T H_k u_k + \\frac{1}{2} u_k^T H_k^T x_k + q_k^T x_k + r_k^T u_k \\right) \\end{aligned} $$System Dynamics The dynamics are typically provided as continuous-time differential equations. To apply iLQR, these dynamics must first be discretized (e.g., using Euler or Runge-Kutta methods). Here we assume general, non-linear, discretized dynamics:\n$$x_{k+1} = f(x_k, u_k)$$which we linearize using a first-order Taylor-series expansion around nominal state and control trajectories:\n$$ X = \\{x_0, \\dots, x_N\\}, U = \\{u_0, \\dots, u_{N-1}\\} $$$$ x_{k+1} + \\delta x_{k+1} = f(x_k + \\delta x_k, u_k + \\delta u_k) \\approx f(x_k, u_k) + \\frac{\\partial f}{\\partial x} \\bigg|_{x_k, u_k} (x - x_k) + \\frac{\\partial f}{\\partial u} \\bigg|_{x_k, u_k} (u - u_k) $$$$ \\delta x_{k+1} = A(x_k, u_k) \\delta x_k + B(x_k, u_k) \\delta u_k $$where $A \\equiv \\frac{\\partial f}{\\partial x}$ and $B \\equiv \\frac{\\partial f}{\\partial u}$.\nSolution We apply Bellman’s optimality condition to define the state value function and Q value function recursively\n$$ \\begin{aligned} V_N \u0026= \\ell_f(x_N)\\\\ Q_k \u0026= \\min_{u_k} \\left\\{ \\ell(x_k, u_k) + V_{k+1}(f(x_k, u_k)) \\right\\}\\\\ V_k \u0026= \\min_{u_k} Q_k(x_k, u_k) \\end{aligned} $$We approximate the state value function as locally quadratic near the nominal trajectory:\n$$ V_k + \\delta V_k = V_k(x_k + \\delta x_k) \\approx V(x_k) + \\left. \\frac{\\partial V}{\\partial x} \\right|_{x_k} (x - x_k) + \\frac{1}{2} (x - x_k)^T \\left. \\frac{\\partial^2 V}{\\partial x^2} \\right|_{x_k} (x - x_k) $$$$ \\delta V_k(x_k) = s_k^T \\delta x_k + \\frac{1}{2} \\delta x_k^T S_k \\delta x_k, $$where we define $s_k \\triangleq \\left.\\frac{\\partial V}{\\partial x}\\right|_{x_k}$ and $S_k \\triangleq \\left.\\frac{\\partial^2 V}{\\partial x^2}\\right|_{x_k}$.\n$$ \\begin{aligned} Q_k + \\delta Q_k \u0026= Q(x_k + \\delta x, u_k + \\delta u) \\\\ \u0026\\approx Q(x_k, u_k) + \\left. \\frac{\\partial Q}{\\partial x} \\right|_{x_k, u_k} (x - x_k) + \\left. \\frac{\\partial Q}{\\partial u} \\right|_{x_k, u_k} (u - u_k)\\\\ \u0026+ \\frac{1}{2} (x - x_k)^T \\left. \\frac{\\partial^2 Q}{\\partial x^2} \\right|_{x_k, u_k} (x - x_k) + \\frac{1}{2} (u - u_k)^T \\left. \\frac{\\partial^2 Q}{\\partial u^2} \\right|_{x_k, u_k} (u - u_k) \\\\ \u0026+ \\frac{1}{2} (u - u_k)^T \\left. \\frac{\\partial^2 Q}{\\partial u \\partial x} \\right|_{x_k, u_k} (x - x_k) + \\frac{1}{2} (x - x_k)^T \\left. \\frac{\\partial^2 Q}{\\partial x \\partial u} \\right|_{x_k, u_k} (u - u_k) \\end{aligned} $$$$ \\delta Q_k(x_k, u_k) = \\frac{1}{2} \\begin{bmatrix} \\delta x_k \\\\ \\delta u_k \\end{bmatrix}^T \\begin{bmatrix} Q_{xx} \u0026 Q_{xu} \\\\ Q_{ux} \u0026 Q_{uu} \\end{bmatrix} \\begin{bmatrix} \\delta x_k \\\\ \\delta u_k \\end{bmatrix} + \\begin{bmatrix} Q_x \\\\ Q_u \\end{bmatrix}^T \\begin{bmatrix} \\delta x_k \\\\ \\delta u_k \\end{bmatrix} $$We define the following variables using matrix calculus:\n$$ \\begin{aligned} Q_x \u0026= \\ell_x + s_{k+1} A_k \\\\ Q_u \u0026= \\ell_u + s_{k+1} B_k \\\\ Q_{xx} \u0026= \\ell_{xx} + A_k^T S_{k+1} A_k\\\\ Q_{uu} \u0026= \\ell_{uu} + B_k^T S_{k+1} B_k\\\\ Q_{ux} \u0026= \\ell_{ux} + B_k^T S_{k+1} A_k \\end{aligned} $$and using the fact the $Q_{ux} = Q_{xu}^T$, which gives us all the values needed to calculate the next step. We can show this by combining Equations 11 and 12:\nBy following a dynamic-programming approach, we can solve the tail problem for $V_N(x)$ for a problem with $N$ time steps. In order to solve the detail, we define $\\delta V$ as the deviation from the optimal value: with $s_N$ and $S_N$ defined as follows, given the cost function in Equation 7:\n$$ \\begin{aligned} s_N \u0026\\equiv \\left. \\frac{\\partial V}{\\partial x} \\right|_{x_N}\\\\ \u0026= \\left. \\frac{\\partial}{\\partial x} \\left( \\frac{1}{2} (x - x_f)^T Q_f (x - x_f) \\right) \\right|_{x_N}\\\\ \u0026= \\left. \\frac{\\partial}{\\partial x} \\left( \\frac{1}{2} x^T Q_f x - x_f^T Q_f x + \\frac{1}{2} x_f^T Q_f x_f \\right) \\right|_{x_N}\\\\ \u0026= Q_f x_N - Q_f x_f \\\\ \u0026= Q_f (x_N - x_f) \\end{aligned} $$$$ \\begin{aligned} S_N \u0026\\equiv \\left. \\frac{\\partial^2 V}{\\partial x^2} \\right|_{x_N}\\\\ \u0026= \\left. \\frac{\\partial}{\\partial x} \\left( Q_f (x - x_f) \\right) \\right|_{x_N}\\\\ \u0026= Q_f \\end{aligned} (Q_f = Q_f^T) $$Solving the Dynamic Programming Problem After solving the tail sub-problem, we can then apply the principle of optimality and define the process for solving for the $k$th time step given the values at the $k+1$th time step.\n$$ \\begin{aligned} V_k \u0026= \\min_{u_k} \\{\\ell(x_k, u_k) + V_{k+1}(f(x_k, u_k))\\}\\\\ \u0026= \\min_{u_k} \\{Q_k(x_k, u_k)\\}\\\\ \\delta V \u0026= \\min_{\\delta u} \\{\\delta Q(x, u)\\}\\\\ \u0026= \\min_{\\delta u} \\{Q_x \\delta x + Q_u \\delta u + \\frac{1}{2} \\delta x^T Q_{xx} \\delta x + \\frac{1}{2} \\delta u^T Q_{uu} \\delta u + \\frac{1}{2} \\delta x^T Q_{xu} \\delta u + \\frac{1}{2} \\delta u^T Q_{ux} \\delta x\\} \\end{aligned}\\tag{1} $$$$ \\frac{\\partial \\delta Q}{\\partial \\delta u} = Q_u + \\frac{1}{2} Q_{ux} \\delta x + \\frac{1}{2} Q_{xu}^T \\delta x + Q_{uu} \\delta u = 0 $$$$ \\Rightarrow \\delta u^* = -Q_{uu}^{-1} (Q_{ux} \\delta x_k + Q_u) = K \\delta x + d $$So,\n$$ \\begin{aligned} d_k \u0026= -Q_{uu}^{-1} Q_u \\\\ K_k \u0026= -Q_{uu}^{-1} Q_{ux} \\end{aligned}. $$After calculating the optimal control as a function of the next time step we can plug it back into Equation (1)\n$$ \\delta Q_k(x_k, u_k) = \\frac{1}{2} \\begin{bmatrix} \\delta x_k \\\\ K \\delta x + d \\end{bmatrix}^T \\begin{bmatrix} Q_{xx} \u0026 Q_{xu} \\\\ Q_{ux} \u0026 Q_{uu} \\end{bmatrix} \\begin{bmatrix} \\delta x_k \\\\ K \\delta x + d \\end{bmatrix} \\begin{bmatrix} Q_x \\\\ Q_u \\end{bmatrix}^T \\begin{bmatrix} \\delta x_k \\\\ K \\delta x + d \\end{bmatrix} $$By equating the result with Equation we get\n$$\\Delta V = \\frac{1}{2} d^T Q_{uu} d + d^T Q_u$$$$s = Q_x + K^T Q_{uu} d + K^T Q_u + Q_{xu}^T d$$$$S = Q_{xx} + K^T Q_{uu} K + K^T Q_{ux} + Q_{ux}^T K$$Forward Pass Since the dynamics and the cost function are only approximated at each time step, it is necessary to iteratively solve the previous problem to successively get closer to the local minimum. After each backward pass solving for the optimal correction in control values, $\\delta u_k^*$, these values are used to calculate a new state trajectory ( $X$) from the nominal trajectories $\\bar{X}, \\bar{U}$, often referred to as a ‘‘rollout’’. The $\\alpha$ term is used for a line search. This is done using the following algorithm:\n$$\\delta x = x_k - \\bar{x}_k$$$$ \\begin{aligned} u_k \u0026= \\bar{u}_k + \\delta u_k^* \\\\ \u0026= \\bar{u}_k + K_k \\delta x_k + \\alpha d_k \\end{aligned} $$$$ x_{k+1} = f(x_k, u_k) $$where $\\alpha$ is the step size, typically used to perform a simple line search.\nSummary The system dynamic is linearized and the objective function is expanded by the second order Taylor series.\nConstrained Iterative Linear Quadratic Regulator Discrete-time Finite-horizon Motion Planning Problem $$ \\begin{aligned} \\arg \\min_{x, u} \u0026\\quad \\left\\{ \\phi(x_N) + \\sum_{k=0}^{N-1} L^k(x_k, u_k) \\right\\} \\\\ \\text{s.t.} \u0026 \\quad x_{k+1} = f^k(x_k, u_k), \\quad k = 0, 1, \\dots, N-1 \\\\ \u0026\\quad x_0 = x_{\\text{start}} \\\\ \u0026\\quad g^k(x_k, u_k) \u003c 0, \\quad k = 0, 1, \\dots, N-1 \\\\ \u0026\\quad g^N(x_N) \u003c 0 \\end{aligned} $$Assumption 1: The system dynamic equation constraints are the only constraints in the problem.\nAssumption 2: The inequality constraints are separated to different time steps.\nAssumption 3: All the functions in the problem have continuous first and second order derivatives.\nHandle Constraints For inequality constraints, we use the barrier function to shape the constraints:\n$$b(g(x, u)) = -\\frac{1}{t} \\log(-g(x, u))$$ The barrier function with different parameter, $t$. Algorithm Constrained iterative linear quadratic regulator algorithm [4]. References [1] https://github.com/AtsushiSakai/PythonRobotics\n[2] J. Chen, W. Zhan, and M. Tomizuka, “Autonomous driving motion planning with constrained iterative LQR,” IEEE Transactions on Intelligent Vehicles, vol. 4, no. 2, pp. 244–254, Jun. 2019.\n[3] https://github.com/pparmesh/Constrained_ILQR/tree/master/scripts\n[4] J. Chen, W. Zhan, and M. Tomizuka, “Constrained iterative LQR for on-road autonomous driving motion planning,” in Proc. 2017 IEEE 20th Int. Conf. Intell. Transp. Syst. (ITSC), Yokohama, Japan, Oct. 2017, pp. 2232–2238.\n[5] “Bézier curve,” Wikipedia, The Free Encyclopedia, [Online]. Available: https://en.wikipedia.org/wiki/B%C3%A9zier_curve.\n","wordCount":"2967","inLanguage":"en","image":"https://livey.github.io/posts/2025-04-16-path-genrating/%3Cimage%20path/url%3E","datePublished":"2025-04-16T00:00:00Z","dateModified":"2025-04-16T00:00:00Z","author":{"@type":"Person","name":"Fuwei Li"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://livey.github.io/posts/2025-04-16-path-genrating/"},"publisher":{"@type":"Organization","name":"Fuwei's Tech Notes","logo":{"@type":"ImageObject","url":"https://livey.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://livey.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://livey.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://livey.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://livey.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://livey.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://livey.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://livey.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Path Generating</h1><div class=post-description>Generating a natural path to connect two given points.</div><div class=post-meta><span title='2025-04-16 00:00:00 +0000 UTC'>April 16, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2967 words&nbsp;·&nbsp;Fuwei Li&nbsp;|&nbsp;<a href=https://github.com/livey/livey.github.io/issues/new rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#path-planning aria-label="Path Planning">Path Planning</a><ul><li><a href=#classical-paths aria-label="Classical Paths">Classical Paths</a><ul><li><a href=#a-star-and-bidirectional-a-star aria-label="A Star and Bidirectional A Star">A Star and Bidirectional A Star</a></li><li><a href=#depth-first-search-bezier-path-and-model-predictive-trajectory aria-label="Depth First Search, Bezier Path, and Model Predictive Trajectory">Depth First Search, Bezier Path, and Model Predictive Trajectory</a></li><li><a href=#voronoi-road-map-and-visibility-road-map aria-label="Voronoi Road Map and Visibility Road Map">Voronoi Road Map and Visibility Road Map</a></li></ul></li></ul></li><li><a href=#quartic-bezier-spline aria-label="Quartic Bezier Spline">Quartic Bezier Spline</a><ul><li><a href=#smoothness-constraint aria-label="Smoothness Constraint">Smoothness Constraint</a><ul><li><a href=#experiments aria-label=Experiments>Experiments</a></li></ul></li><li><a href=#minimum-variation-of-curvature aria-label="Minimum Variation of Curvature">Minimum Variation of Curvature</a><ul><li><a href=#numerical-consideration aria-label="Numerical consideration">Numerical consideration</a></li><li><a href=#algorithm aria-label=Algorithm>Algorithm</a></li></ul></li><li><a href=#experiments-1 aria-label=Experiments>Experiments</a><ul><li><a href=#with-and-without-mathbf-p_2-constraint aria-label="With and Without $\mathbf p_2$ Constraint">With and Without $\mathbf p_2$ Constraint</a></li><li><a href=#different-curvature-constraints aria-label="Different Curvature Constraints">Different Curvature Constraints</a></li><li><a href=#failure-case aria-label="Failure Case">Failure Case</a></li><li><a href=#specialized-mathbfp_2-initialization aria-label="Specialized $\mathbf{p}_2$ initialization">Specialized $\mathbf{p}_2$ initialization</a></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></li></ul></li><li><a href=#appendix aria-label=Appendix>Appendix</a><ul><li><a href=#ego-vehicle-dynamics aria-label="Ego vehicle dynamics">Ego vehicle dynamics</a><ul><li><a href=#state-cost aria-label="State Cost">State Cost</a><ul><li><a href=#end-state-cost aria-label="End State Cost">End State Cost</a></li><li><a href=#intermediate-state-cost aria-label="Intermediate State Cost">Intermediate State Cost</a></li></ul></li><li><a href=#constraints aria-label=Constraints>Constraints</a><ul><li><a href=#low-and-high-acceleration-bounds aria-label="Low and high acceleration bounds">Low and high acceleration bounds</a></li><li><a href=#low-and-high-yaw-rate-bounds aria-label="Low and high yaw rate bounds">Low and high yaw rate bounds</a></li><li><a href=#obstacle-constraints aria-label="Obstacle constraints">Obstacle constraints</a></li></ul></li></ul></li><li><a href=#linear-quadratic-regulator aria-label="Linear Quadratic Regulator">Linear Quadratic Regulator</a><ul><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#solution aria-label=Solution>Solution</a></li><li><a href=#summary-1 aria-label=Summary>Summary</a></li></ul></li><li><a href=#iterative-linear-quadratic-regulator aria-label="Iterative Linear Quadratic Regulator">Iterative Linear Quadratic Regulator</a><ul><li><a href=#problem-1 aria-label=Problem>Problem</a></li><li><a href=#cost-function aria-label="Cost Function">Cost Function</a></li><li><a href=#system-dynamics aria-label="System Dynamics">System Dynamics</a></li><li><a href=#solution-1 aria-label=Solution>Solution</a><ul><li><a href=#solving-the-dynamic-programming-problem aria-label="Solving the Dynamic Programming Problem">Solving the Dynamic Programming Problem</a></li><li><a href=#forward-pass aria-label="Forward Pass">Forward Pass</a></li></ul></li><li><a href=#summary-2 aria-label=Summary>Summary</a></li></ul></li><li><a href=#constrained-iterative-linear-quadratic-regulator aria-label="Constrained Iterative Linear Quadratic Regulator">Constrained Iterative Linear Quadratic Regulator</a><ul><li><a href=#discrete-time-finite-horizon-motion-planning-problem aria-label="Discrete-time Finite-horizon Motion Planning Problem">Discrete-time Finite-horizon Motion Planning Problem</a></li><li><a href=#handle-constraints aria-label="Handle Constraints">Handle Constraints</a></li><li><a href=#algorithm-1 aria-label=Algorithm>Algorithm</a></li></ul></li></ul></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>Given a starting point, starting direction, ending point, and ending direction, the goal is to generate a feasible and &ldquo;natural&rdquo; path that connects the two points. This path should adhere to vehicle dynamics and avoids obstacles. However, it is hard to define what is &ldquo;natural&rdquo;.</p><h1 id=path-planning>Path Planning<a hidden class=anchor aria-hidden=true href=#path-planning>#</a></h1><p>In this section, we review some classical path planning methods. We ignore the algorithmic details and focus on the resulting path shapes to provide an overview.
The demonstration images are generated using the code repository [1].</p><h2 id=classical-paths>Classical Paths<a hidden class=anchor aria-hidden=true href=#classical-paths>#</a></h2><h3 id=a-star-and-bidirectional-a-star>A Star and Bidirectional A Star<a hidden class=anchor aria-hidden=true href=#a-star-and-bidirectional-a-star>#</a></h3><figure style=text-align:center><div style=display:flex;justify-content:center;gap:10px><img src=./resources/image-12.png alt="A star" style=width:48%>
<img src=./resources/image-11.png alt="Bidirectional A star" style=width:48%></div><figcaption style=font-weight:400>Left: A* search. Right: bidirectional A* search.</figcaption></figure><h3 id=depth-first-search-bezier-path-and-model-predictive-trajectory>Depth First Search, Bezier Path, and Model Predictive Trajectory<a hidden class=anchor aria-hidden=true href=#depth-first-search-bezier-path-and-model-predictive-trajectory>#</a></h3><figure style=text-align:center><div style=display:flex;justify-content:center;gap:10px><img src=./resources/image-14.png alt="Depth First Search" style=width:32%>
<img src=./resources/image-10.png alt="Bezier Path" style=width:32%>
<img src=./resources/image-13.png alt="Model Predictive Trajectory Generator" style=width:32%></div><figcaption style=font-weight:400>Left: depth first search. Middle: Bezier path. Right: model predictive trajectory.</figcaption></figure><h3 id=voronoi-road-map-and-visibility-road-map>Voronoi Road Map and Visibility Road Map<a hidden class=anchor aria-hidden=true href=#voronoi-road-map-and-visibility-road-map>#</a></h3><figure style=text-align:center><div style=display:flex;justify-content:center;gap:10px><img src=./resources/image-7.png alt="Voronoi Road Map" style=width:32%>
<img src=./resources/image-6.png alt="Voronoi Failed in open space" style=width:32%>
<img src=./resources/image-8.png alt="Visibility Road Map" style=width:32%></div><figcaption style=font-weight:400>Left: Voronoi road map. Middle: Voronoi fails in open space. Right: visibility road map.</figcaption></figure><h1 id=quartic-bezier-spline>Quartic Bezier Spline<a hidden class=anchor aria-hidden=true href=#quartic-bezier-spline>#</a></h1><p>We find that the quartic Bezier spline works well for scenarios involving right turns, U-turns, and lane changes [5].</p><p>A quartic Bezier spline is defined by five control points, $\mathbf p_0, \mathbf p_1, \mathbf p_2, \mathbf p_3, \mathbf p_4$, with parameters $t \in [0, 1]$, and is given by</p>$$B(t) = \sum_{i=0}^{4} \binom{4}{i}\, t^i\,(1 - t)^{4-i} \mathbf{p}_i.
$$<p>When $t = 0$, $B(0) = \mathbf{p}_0$ and $t = 1$, $B(1) = \mathbf{p}_4$. Then, $\mathbf{p}_0$ and $\mathbf{p}_4$ are the start and end points, respectively.</p><p>Let us define $B_{i,n}(t)=\binom{n}{i}\, t^i\,(1 - t)^{n-i}$. Then, the quartic Bezier spline can be rewritten as:</p>$$
B(t) = \sum_{i=0}^4 B_{i,4}(t) \mathbf{p}_i.
$$<p>To compute the derivative of the quartic Bezier spline, let us first compute the derivative of $B_{i,n}(t)$:</p>$$
\frac{d}{dt}B_{i,n}(t) = n \left(B_{i-1,n-1}(t) - B_{i,n-1}(t)\right).
$$<p>Then the derivative of the quartic Bezier spline is:</p>$$
\begin{aligned}
B^\prime(t)
&= 4 \sum_{i=1}^4 B_{i-1, 3}(t)\mathbf{p}_{i} - 4 \sum_{i=0}^3 B_{i, 3}(t)\mathbf{p}_{i} \\
&= 4 \sum_{i=0}^3 B_{i, 3}(t)\left(\mathbf{p}_{i+1} - \mathbf{p}_{i}\right).
\end{aligned}
$$<p>Observing that</p>$$
B^\prime(0) = 4 \sum_{i=0}^3 B_{i, 3}(0)\left(\mathbf{p}_{i+1} - \mathbf{p}_{i}\right) = 4 \left(\mathbf{p}_1 - \mathbf{p}_0\right),
$$$$
B^\prime(1) = 4 \sum_{i=0}^3 B_{i, 3}(1)\left(\mathbf{p}_{i+1} - \mathbf{p}_{i}\right) = 4 \left(\mathbf{p}_4 - \mathbf{p}_3\right).
$$<h2 id=smoothness-constraint>Smoothness Constraint<a hidden class=anchor aria-hidden=true href=#smoothness-constraint>#</a></h2><p>Suppose the start unit direction is $\mathbf{d}_0$ and the end unit direction is $\mathbf{d}_4$. To ensure the path curve is smooth at the start and end points, we constrain the path&rsquo;s first derivative to match the given directions. So, we have $\mathbf{d}_0 \propto \mathbf{p}_1 - \mathbf{p}_0$ and $\mathbf{d}_4 \propto \mathbf{p}_4 - \mathbf{p}_3$. Then, the control points $\mathbf{p}_1$ and $\mathbf{p}_3$ are along the start and end directions, respectively,</p>$$\mathbf{p}_1 = \mathbf{p}_0 + \alpha \mathbf{d}_0, \quad \mathbf{p}_3 = \mathbf{p}_4 - \beta \mathbf{d}_4,$$<p>where $\alpha$ and $\beta$ are positive scalars.</p><h3 id=experiments>Experiments<a hidden class=anchor aria-hidden=true href=#experiments>#</a></h3><p>In this experiment, we impose derivative constraints only at the start and end points and explore the resulting path shapes.</p><p>We make the starting points at $(0, 0)$ with normalized direction $(1,0)$
We test right turn, U-turn, and lane change, with ending points and directions pairs $[(15, -9), (0, -1)], [(0, 10), (-1, 0)], [(13, 2), (1, 0)]$, respectively.</p><figure style=text-align:center><div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:5px"><img src=./resources/image.png alt="Right turn scenario" style=width:100%>
<img src=./resources/image-1.png alt="U-turn scenario" style=width:100%>
<img src=./resources/image-2.png alt="Lane change scenario" style=width:100%>
<img src=./resources/image-3.png alt="Right turn (enlarged)" style=width:100%>
<img src=./resources/image-4.png alt="U-turn (enlarged)" style=width:100%>
<img src=./resources/image-5.png alt="Lane change (enlarged)" style=width:100%></div><figcaption style=font-weight:400>First column: Right turn; Second column: U-turn; Third column: Lane change. Two rows represent different control points.</figcaption></figure><h2 id=minimum-variation-of-curvature>Minimum Variation of Curvature<a hidden class=anchor aria-hidden=true href=#minimum-variation-of-curvature>#</a></h2><p>Defining a &ldquo;natural&rdquo; path presents another challenge. The first idea is the model predictive trajectory. However, model predictive trajectory relies on a reference trajectory, which is also difficult to define. After reviewing relevant research, especially regarding model predictive references (e.g., [2,4]), we employ the minimum variation of curvature as our objective to fulfill our requirements. The variation of the curvature is defined as:</p>$$
V=\int_0^1\left(\frac{d\kappa(t)}{dt}\right)^2\,dt,
$$<p>where $\kappa(t)$ is the curvature of the path at $t$ and can be computed by:</p>$$
\kappa(t) = \frac{\|B^\prime(t)\times B^{\prime \prime}(t)\|}{\|B^\prime(t)\|^3},
$$<p>where the second derivative of the quartic Bezier curve is:</p>$$
B^{\prime \prime}(t) = 12 \sum_{i=0}^{2} B_{i,2}(t)(\mathbf{p}_{i+2} - 2\mathbf{p}_{i+1} + \mathbf{p}_i).
$$<p>Further, we only put maximal curvature constraint as a simplified representation of vehicle dynamic constraints. Meanwhile, we add the distance to obstacles as a hard constraint.</p><p>In summary, our optimization problem&rsquo;s objective is to minimize the variation of the curvature:</p>$$
\min_{\alpha, \beta, \lambda} \int_0^1\left(\frac{d\kappa(t)}{dt}\right)^2\,dt,
$$<p>with constraints:</p><p><strong>1</strong>. The curve is smooth at the starting point, meaning the second control point lies along the initial direction:</p>$$
\mathbf p_1 = \mathbf p_0 + \alpha L \mathbf d_0
$$<p>the same constraint applies to the end point, leading to the fourth control point,</p>$$
\mathbf p_3 = \mathbf p_4 - \beta L \mathbf d_4
$$<p>where $0 < \alpha, \beta < 1$, where $L = \|\mathbf{p}_0 - \mathbf{p}_4 \|$ is the distance between the start and end points.</p><p><strong>2</strong>. To further simplify the optimization variables, we introduce an optional constraint where the third control point, $\mathbf p_2$, lies on the line segment between $\mathbf p_1$ and $\mathbf p_3$:</p>$$
\mathbf p_2 = \lambda \mathbf p_1 + (1-\lambda)\mathbf p_3
$$<p>where $0 \le \lambda \le 1$. Depending on the complexity of the environment, this constraint is optional.</p><p><strong>3</strong>. Maximal curvature constraint</p>$$
\kappa(t) \le \kappa_{max}
$$<p><strong>4</strong>. Distances to obstacles</p>$$
d\left(B(t), \mathbf{M}_i\right) \ge r_i, \text{ for all } i = 1, 2, \cdots, M \text{ and } t \in [0, 1]
$$<p>where we model the $i$-th obstacle, $\mathbf{M}_i$, as a circle with radius $r_i$.</p><h3 id=numerical-consideration>Numerical consideration<a hidden class=anchor aria-hidden=true href=#numerical-consideration>#</a></h3><p>The variation of curvature constraint is hard to implement directly. We use its numerical approximation:</p>$$
\frac{d\kappa(t_i)}{dt}\approx \frac{\kappa(t_i) - \kappa(t_{i-1})}{\Delta t}
$$<p>The curvature</p>$$
\begin{aligned}
\kappa(t)
&= \frac{\|B^\prime(t)\times B^{\prime \prime}(t)\|}{\|B^\prime(t)\|^3}\\
&= \frac{B_x^\prime(t)B_Y^{\prime \prime} - B_y^\prime(t)B_x^{\prime \prime(t)}}{(B_x^\prime(t)^2 + B_y^\prime(t)^2)^{3/2}}
\end{aligned}
$$<h3 id=algorithm>Algorithm<a hidden class=anchor aria-hidden=true href=#algorithm>#</a></h3><p>The algorithm proceeds as follows:</p><ol><li><p>Divide parameter, $t$, space, $[0, 1]$, into $N$ equally spaced intervals, with $\{t_i\}_{i=0}^{N}$</p></li><li><p>Compute $\kappa(t_i)$, $\frac{d\kappa(t_i)}{dt}$, and total variation, $V$, numerically</p></li><li><p>Use an optimization algorithm (e.g., Sequential Least-Squares Programming (SLSQP)) to solve the optimization problem.</p></li></ol><h2 id=experiments-1>Experiments<a hidden class=anchor aria-hidden=true href=#experiments-1>#</a></h2><h3 id=with-and-without-mathbf-p_2-constraint>With and Without $\mathbf p_2$ Constraint<a hidden class=anchor aria-hidden=true href=#with-and-without-mathbf-p_2-constraint>#</a></h3><table><thead><tr><th style=text-align:center>Constrained</th><th style=text-align:center>Unconstrained</th></tr></thead><tbody><tr><td style=text-align:center><img alt="Constrained: Path 1" loading=lazy src=/posts/2025-04-16-path-genrating/resources/image-9.png></td><td style=text-align:center><img alt="Unconstrained: Path 1" loading=lazy src=/posts/2025-04-16-path-genrating/resources/image-25.png></td></tr><tr><td style=text-align:center><img alt="Constrained: Path 2 [25, -9]" loading=lazy src=/posts/2025-04-16-path-genrating/resources/image-27.png></td><td style=text-align:center><img alt="Unconstrained: Path 2 [25, -9]" loading=lazy src=/posts/2025-04-16-path-genrating/resources/image-15.png></td></tr><tr><td style=text-align:center><img alt="Constrained: Path 3 [12, 12]" loading=lazy src=/posts/2025-04-16-path-genrating/resources/image-26.png></td><td style=text-align:center><img alt="Unconstrained: Path 3 [12, 12]" loading=lazy src=/posts/2025-04-16-path-genrating/resources/image-16.png></td></tr><tr><td style=text-align:center><img alt="Constrained: Path 4" loading=lazy src=/posts/2025-04-16-path-genrating/resources/image-29.png></td><td style=text-align:center><img alt="Unconstrained: Path 4" loading=lazy src=/posts/2025-04-16-path-genrating/resources/image-24.png></td></tr><tr><td style=text-align:center><img alt="Constrained: Path 5" loading=lazy src=/posts/2025-04-16-path-genrating/resources/image-28.png></td><td style=text-align:center><img alt="Unconstrained: Path 5" loading=lazy src=/posts/2025-04-16-path-genrating/resources/image-23.png></td></tr></tbody></table><p><em>Comparison of generated paths. Left column: $\mathbf{p}_2$ constrained. Right column: $\mathbf{p}_2$ unconstrained.</em></p><p>The results indicate that the path generated without the $\mathbf p_2$ constraint appears more natural.</p><h3 id=different-curvature-constraints>Different Curvature Constraints<a hidden class=anchor aria-hidden=true href=#different-curvature-constraints>#</a></h3><figure style=text-align:center><div style=display:flex;justify-content:center;gap:10px><img src=./resources/image-21.png alt="Obstacle radius = 5, maximal curvature = 1/3.0, failed" style=width:48%>
<img src=./resources/image-22.png alt="Obstacle radius = 4, maximal curvature = 1/6.0, failed" style=width:48%></div><figcaption style=font-weight:400;margin-top:10px>Left: Max curvature 1/6.0 (failed). Right: Max curvature 1/3.0 (successful).</figcaption></figure><h3 id=failure-case>Failure Case<a hidden class=anchor aria-hidden=true href=#failure-case>#</a></h3><p>Applying non-judiciously chosen initial variables can result in failure.</p><figure style=text-align:center><div style=display:flex;justify-content:center;gap:10px><img src=./resources/image-30.png alt="Failure case: Obstacle collision" style=width:48%>
<img src=./resources/image-32.png alt="Failure case: Increased sampling leads to failure" style=width:48%></div><figcaption style=font-weight:400;margin-top:10px>Left: Failure occurs due to a poor initial guess. Right: Increasing the number of sampling points can also lead to failure.</figcaption></figure><h3 id=specialized-mathbfp_2-initialization>Specialized $\mathbf{p}_2$ initialization<a hidden class=anchor aria-hidden=true href=#specialized-mathbfp_2-initialization>#</a></h3><figure style=text-align:center><div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:5px"><img src=./resources/image-42.png alt="Image 42" style=width:100%>
<img src=./resources/image-43.png alt="Image 43" style=width:100%>
<img src=./resources/image-41.png alt="Image 41" style=width:100%>
<img src=./resources/image-38.png alt="Image 38" style=width:100%>
<img src=./resources/image-39.png alt="Obstacle radius = 9" style=width:100%>
<img src=./resources/image-40.png alt="Image 40" style=width:100%>
<img src=./resources/image-36.png alt="Image 36" style=width:100%>
<img src=./resources/image-37.png alt="Image 37" style=width:100%>
<img src=./resources/image-33.png alt="Image 33" style=width:100%></div><figcaption style=font-weight:400;margin-top:10px>Paths generated using specialized P2 initialization for various scenarios and obstacle configurations.</figcaption></figure><h3 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h3><p>To accelerate the optimization, we incrementally add constraints, starting from the simplest, to find a feasible solution.</p><p>The optimization variables sets are:</p><ol><li>$\alpha, \beta, \lambda$</li><li>$\alpha, \beta, \mathbf{p}_2$</li></ol><p>The constraint sets considered are:</p><ol><li>No direct constraints</li><li>Maximal curvature</li><li>Obstacle avoidance</li></ol><p>Our workflow is illustrated below:
<img loading=lazy src=/posts/2025-04-16-path-genrating/resources/diagram.png>
where $O_i$ and $C_{j}$, denote the $(i)$th and $(j)$th objective and constraint, respectively.</p><p>Some examples are shown below:</p><figure style=text-align:center><div style="display:grid;grid-template-columns:1fr 1fr;gap:10px"><img src=./resources/image-17.png alt="Obstacle radius = 1, find solution with O1" style=width:100%>
<img src=./resources/image-18.png alt="Obstacle radius = 2, find a solution with O1+C2+C3" style=width:100%>
<img src=./resources/image-19.png alt="Obstacle radius = 3, find a solution with O2+C2+C3" style=width:100%>
<img src=./resources/image-20.png alt="Obstacle radius = 4, find a solution with O2+C2+C3" style=width:100%></div><figcaption style=font-weight:400;margin-top:10px>Paths generated with different obstacle radii and optimization settings. Top-left: r=1, O1. Top-right: r=2, O1+C2+C3. Bottom-left: r=3, O2+C2+C3. Bottom-right: r=4, O2+C2+C3.</figcaption></figure><h1 id=appendix>Appendix<a hidden class=anchor aria-hidden=true href=#appendix>#</a></h1><h2 id=ego-vehicle-dynamics>Ego vehicle dynamics<a hidden class=anchor aria-hidden=true href=#ego-vehicle-dynamics>#</a></h2><p>This work utilizes a kinematic bicycle model. The vehicle state is represented by:</p>$$
X = [x \, y \, v \, \theta]
$$<p>where $x$, $y$ is the 2D position of the vehicle, $v$ is the vehicle speed, and $\theta$ is the vehicle&rsquo;s yaw. The vehicle dynamics are described by:</p>$$
\dot{X} =
\begin{bmatrix}
v \cos \theta \\
v \sin \theta \\
0 \\
0
\end{bmatrix}
\begin{bmatrix}
0 & 0 \\
0 & 0 \\
1 & 0 \\
0 & 1
\end{bmatrix}
\begin{bmatrix}
\dot{v} \\
\dot{\theta}
\end{bmatrix}
$$<p>As we are dealing in discrete time domain, the state update equation becomes:</p>$$X_{k+1} = \begin{bmatrix} x_{k+1} \\ y_{k+1} \\ v_{k+1} \\ \theta_{k+1} \end{bmatrix}^T = f(x_k, u_k)$$<p>where</p>$$x_{k+1} = x_k + \cos\theta_k \left( v_k T_s + \frac{\dot{v}_k}{2} T_s^2 \right)$$$$y_{k+1} = y_k + \sin\theta_k \left( v_k T_s + \frac{\dot{v}_k}{2} T_s^2 \right)$$<p>and</p>$$v_{k+1} = v_k + \dot{v}_k T_s$$$$\theta_{k+1} = \theta_k + \dot{\theta}_k T_s$$<h3 id=state-cost>State Cost<a hidden class=anchor aria-hidden=true href=#state-cost>#</a></h3><h4 id=end-state-cost>End State Cost<a hidden class=anchor aria-hidden=true href=#end-state-cost>#</a></h4><p>We aim for the terminal state to match a desired state,</p>$$
\mathbf{x}_e = [x_e, y_e, v_e, \theta_e]
$$<p>So, the end state cost is</p>$$
(\mathbf{x}-\mathbf{x}_e)^\top\Lambda (\mathbf{x}-\mathbf{x}_e)
$$$$\Lambda = \text{diag}(\lambda_x^e, \lambda^e_y, 0, \lambda_\theta^e)
$$<h4 id=intermediate-state-cost>Intermediate State Cost<a hidden class=anchor aria-hidden=true href=#intermediate-state-cost>#</a></h4><ul><li><p>Acceleration</p></li><li><p>Yaw rate</p></li><li><p>Desired velocity tracking</p></li></ul><h3 id=constraints>Constraints<a hidden class=anchor aria-hidden=true href=#constraints>#</a></h3><figure style=text-align:center><img src=./resources/image-35.png alt="The approximated object using ellipses and circles." style="width:100%;margin:0 auto;display:block"><figcaption style=font-weight:400>The approximated object using ellipses and circles.</figcaption></figure><h4 id=low-and-high-acceleration-bounds>Low and high acceleration bounds<a hidden class=anchor aria-hidden=true href=#low-and-high-acceleration-bounds>#</a></h4><h4 id=low-and-high-yaw-rate-bounds>Low and high yaw rate bounds<a hidden class=anchor aria-hidden=true href=#low-and-high-yaw-rate-bounds>#</a></h4><h4 id=obstacle-constraints>Obstacle constraints<a hidden class=anchor aria-hidden=true href=#obstacle-constraints>#</a></h4><p>Obstacles are represented by points in the plane. So, for each obstacle point, $\mathbf{x}^o_i$, we must have</p>$$d(\mathbf{x}, \mathbf{x}^o_i) > 0
$$<h2 id=linear-quadratic-regulator>Linear Quadratic Regulator<a hidden class=anchor aria-hidden=true href=#linear-quadratic-regulator>#</a></h2><h3 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h3>$$
\begin{aligned}
\underset{x_1, \dots,x_N, u_1,\dots, u_N }{\text{argmin}} &\quad \frac{1}{2} x_N^T Q_N x_N + \frac{1}{2} \sum_{k=1}^{N-1} x_k^T Q_k x_k + u_k^T R_k u_k \\
s.t. &\quad
x_{k+1} = A_k x_t + B_k u_k
\end{aligned}
$$<p>Here, the objective function is quadratic with respect to states and controls, and the system transition is linear.</p><h3 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h3><p>This problem can be solved using dynamic programming. The solution reveals that the state value function is quadratic, and the optimal policy is linear with respect to the state.</p><p>Firstly, the state value function $V(\mathbf{x}_N)$ is known as</p>$$V(\mathbf{x}_N) = \frac{1}{2}\mathbf{x}_N^\top\mathbf{Q}_N\mathbf{x}_N$$<p>The state value function, $V(\mathbf{x}_{N-1})$, can be computed by</p>$$
V(\mathbf{x}_{N-1}) = \min_{\mathbf{u}_{N-1}}
\frac{1}{2}\mathbf{x}_{N-1}^\top\mathbf{Q}_{N-1}\mathbf{x}_{N-1} +
\frac{1}{2}\mathbf{u}_{N-1}\mathbf{R}_{N-1}\mathbf{u}_{N-1} +
V(\mathbf{x}_N)
$$<p>Observing that the function is quadratic with respect to $\mathbf{u}_{N-1}$, taking gradient of the state function with respect to $\mathbf{u}_{N-1}$ and set to zero we have</p>$$
\begin{aligned}
u^*_{N-1} &= -\left( R_{N-1} + B_{N-1}^T S_N B_{N-1} \right)^{-1} B_{N-1}^T S_N A_{N-1} x_{N-1} \\
&\equiv K_{N-1} x_{N-1}
\end{aligned}
$$<p>where we define $S_N = Q_N$, and the state value function is</p>$$
\begin{aligned}
V_{N-1}(x_{N-1}) &= \frac{1}{2} x_{N-1}^T Q_{N-1} x_{N-1} + \frac{1}{2} x_{N-1}^T K_{N-1}^T R_{N-1} K_{N-1} x_{N-1} \\
&\quad + \frac{1}{2} \left( A_{N-1} x_{N-1} + B_{N-1} K_{N-1} x_{N-1} \right)^T P_N \left( A_{N-1} x_{N-1} + B_{N-1} K_{N-1} x_{N-1} \right) \\
&= \frac{1}{2} x_{N-1}^T \left( Q_{N-1} + K_{N-1}^T R_{N-1} K_{N-1} + \left( A_{N-1} + B_{N-1} K_{N-1} \right)^T S_N \left( A_{N-1} + B_{N-1} K_{N-1} \right) \right) x_{N-1} \\
&\equiv \frac{1}{2} x_{N-1}^T S_N x_{N-1}
\end{aligned}
$$<h3 id=summary-1>Summary<a hidden class=anchor aria-hidden=true href=#summary-1>#</a></h3><p>In the LQR, the objective is quadratic with respect to the state and control, and the optimal control is a linear function of the state.</p><h2 id=iterative-linear-quadratic-regulator>Iterative Linear Quadratic Regulator<a hidden class=anchor aria-hidden=true href=#iterative-linear-quadratic-regulator>#</a></h2><h3 id=problem-1>Problem<a hidden class=anchor aria-hidden=true href=#problem-1>#</a></h3>$$
\begin{aligned}
\underset{\mathbf{x}_1,\dots,\mathbf{x}_N, \mathbf{u}_1,\dots,\mathbf{u}_N}{\text{argmin}} &\quad \ell({\mathbf{x}_N})+ \sum_{k=1}^{N-1}\ell(\mathbf{x}_k, \mathbf{u}_k)\\
s.t. & \quad \mathbf{x}_{k+1} = f(\mathbf{x}_k, \mathbf{u}_k)
\end{aligned}
$$<p>where the objective function is twice differentiable and the system dynamic is differentiable.</p><p>We expand the cost function and system dynamic along a nominal trajectory.</p><h3 id=cost-function>Cost Function<a hidden class=anchor aria-hidden=true href=#cost-function>#</a></h3><p>Many cost functions used in iLQR are quadratic. If the cost function is not quadratic, a second-order Taylor series expansion approximates it quadratically. Similarly, the dynamics are linearized using a first-order Taylor expansion. Note that constant terms in the cost expansion are dropped as they do not affect the minimization:</p>$$
\begin{aligned}
J(x_0, U) &= \ell_f(x_N) + \sum_{k=1}^{N-1} \ell(x_k, u_k)\\
&\approx \frac{1}{2} x_N^T Q_N x_N + q_N^T x_N + \sum_{k=1}^{N-1} \left( \frac{1}{2} x_k^T Q_k x_k + \frac{1}{2} u_k^T R_k u_k + \frac{1}{2} x_k^T H_k u_k + \frac{1}{2} u_k^T H_k^T x_k + q_k^T x_k + r_k^T u_k \right)
\end{aligned}
$$<h3 id=system-dynamics>System Dynamics<a hidden class=anchor aria-hidden=true href=#system-dynamics>#</a></h3><p>The dynamics are typically provided as continuous-time differential equations. To apply iLQR, these dynamics must first be discretized (e.g., using Euler or Runge-Kutta methods). Here we assume general, non-linear, discretized dynamics:</p>$$x_{k+1} = f(x_k, u_k)$$<p>which we linearize using a first-order Taylor-series expansion around nominal state and control trajectories:</p>$$
X = \{x_0, \dots, x_N\}, U = \{u_0, \dots, u_{N-1}\}
$$$$
x_{k+1} + \delta x_{k+1} = f(x_k + \delta x_k, u_k + \delta u_k) \approx f(x_k, u_k) + \frac{\partial f}{\partial x} \bigg|_{x_k, u_k} (x - x_k) + \frac{\partial f}{\partial u} \bigg|_{x_k, u_k} (u - u_k)
$$$$
\delta x_{k+1} = A(x_k, u_k) \delta x_k + B(x_k, u_k) \delta u_k
$$<p>where $A \equiv \frac{\partial f}{\partial x}$ and $B \equiv \frac{\partial f}{\partial u}$.</p><h3 id=solution-1>Solution<a hidden class=anchor aria-hidden=true href=#solution-1>#</a></h3><p>We apply Bellman&rsquo;s optimality condition to define the state value function and Q value function recursively</p>$$
\begin{aligned}
V_N &= \ell_f(x_N)\\
Q_k &= \min_{u_k} \left\{ \ell(x_k, u_k) + V_{k+1}(f(x_k, u_k)) \right\}\\
V_k &= \min_{u_k} Q_k(x_k, u_k)
\end{aligned}
$$<p>We approximate the state value function as locally quadratic near the nominal trajectory:</p>$$
V_k + \delta V_k = V_k(x_k + \delta x_k) \approx V(x_k) + \left. \frac{\partial V}{\partial x} \right|_{x_k} (x - x_k) + \frac{1}{2} (x - x_k)^T \left. \frac{\partial^2 V}{\partial x^2} \right|_{x_k} (x - x_k)
$$$$
\delta V_k(x_k) = s_k^T \delta x_k + \frac{1}{2} \delta x_k^T S_k \delta x_k,
$$<p>where we define $s_k \triangleq \left.\frac{\partial V}{\partial x}\right|_{x_k}$ and $S_k \triangleq \left.\frac{\partial^2 V}{\partial x^2}\right|_{x_k}$.</p>$$
\begin{aligned}
Q_k + \delta Q_k &= Q(x_k + \delta x, u_k + \delta u) \\
&\approx Q(x_k, u_k) + \left. \frac{\partial Q}{\partial x} \right|_{x_k, u_k} (x - x_k) + \left. \frac{\partial Q}{\partial u} \right|_{x_k, u_k} (u - u_k)\\
&+
\frac{1}{2} (x - x_k)^T \left. \frac{\partial^2 Q}{\partial x^2} \right|_{x_k, u_k} (x - x_k) + \frac{1}{2} (u - u_k)^T \left. \frac{\partial^2 Q}{\partial u^2} \right|_{x_k, u_k} (u - u_k) \\
&+ 
\frac{1}{2} (u - u_k)^T \left. \frac{\partial^2 Q}{\partial u \partial x} \right|_{x_k, u_k} (x - x_k) +
\frac{1}{2} (x - x_k)^T \left. \frac{\partial^2 Q}{\partial x \partial u} \right|_{x_k, u_k} (u - u_k)
\end{aligned}
$$$$
\delta Q_k(x_k, u_k) = \frac{1}{2}
\begin{bmatrix}
\delta x_k \\
\delta u_k
\end{bmatrix}^T
\begin{bmatrix}
Q_{xx} & Q_{xu} \\
Q_{ux} & Q_{uu}
\end{bmatrix}
\begin{bmatrix}
\delta x_k \\
\delta u_k
\end{bmatrix} +
\begin{bmatrix}
Q_x \\
Q_u
\end{bmatrix}^T
\begin{bmatrix}
\delta x_k \\
\delta u_k
\end{bmatrix}
$$<p>We define the following variables using matrix calculus:</p>$$
\begin{aligned}
Q_x &= \ell_x + s_{k+1} A_k \\
Q_u &= \ell_u + s_{k+1} B_k \\
Q_{xx} &= \ell_{xx} + A_k^T S_{k+1} A_k\\
Q_{uu} &= \ell_{uu} + B_k^T S_{k+1} B_k\\
Q_{ux} &= \ell_{ux} + B_k^T S_{k+1} A_k
\end{aligned}
$$<p>and using the fact the $Q_{ux} = Q_{xu}^T$, which gives us all the values needed to calculate the next step. We can show this by combining Equations 11 and 12:</p><p>By following a dynamic-programming approach, we can solve the tail problem for $V_N(x)$ for a problem with $N$ time steps. In order to solve the detail, we define $\delta V$ as the deviation from the optimal value: with $s_N$ and $S_N$ defined as follows, given the cost function in Equation 7:</p>$$
\begin{aligned}
s_N &\equiv \left. \frac{\partial V}{\partial x} \right|_{x_N}\\
&= \left. \frac{\partial}{\partial x} \left( \frac{1}{2} (x - x_f)^T Q_f (x - x_f) \right) \right|_{x_N}\\
&= \left. \frac{\partial}{\partial x} \left( \frac{1}{2} x^T Q_f x - x_f^T Q_f x + \frac{1}{2} x_f^T Q_f x_f \right) \right|_{x_N}\\
&= Q_f x_N - Q_f x_f \\
&= Q_f (x_N - x_f)
\end{aligned}
$$$$
\begin{aligned}
S_N &\equiv \left. \frac{\partial^2 V}{\partial x^2} \right|_{x_N}\\
&= \left. \frac{\partial}{\partial x} \left( Q_f (x - x_f) \right) \right|_{x_N}\\
&= Q_f
\end{aligned}
(Q_f = Q_f^T)
$$<h4 id=solving-the-dynamic-programming-problem>Solving the Dynamic Programming Problem<a hidden class=anchor aria-hidden=true href=#solving-the-dynamic-programming-problem>#</a></h4><p>After solving the tail sub-problem, we can then apply the principle of optimality and define the process for solving for the $k$th time step given the values at the $k+1$th time step.</p>$$
\begin{aligned}
V_k &= \min_{u_k} \{\ell(x_k, u_k) + V_{k+1}(f(x_k, u_k))\}\\
&= \min_{u_k} \{Q_k(x_k, u_k)\}\\
\delta V &= \min_{\delta u} \{\delta Q(x, u)\}\\
&= \min_{\delta u} \{Q_x \delta x + Q_u \delta u + \frac{1}{2} \delta x^T Q_{xx} \delta x + \frac{1}{2} \delta u^T Q_{uu} \delta u + \frac{1}{2} \delta x^T Q_{xu} \delta u + \frac{1}{2} \delta u^T Q_{ux} \delta x\}
\end{aligned}\tag{1}
$$$$
\frac{\partial \delta Q}{\partial \delta u} = Q_u + \frac{1}{2} Q_{ux} \delta x + \frac{1}{2} Q_{xu}^T \delta x + Q_{uu} \delta u = 0
$$$$
\Rightarrow \delta u^* = -Q_{uu}^{-1} (Q_{ux} \delta x_k + Q_u) = K \delta x + d
$$<p>So,</p>$$
\begin{aligned}
d_k &= -Q_{uu}^{-1} Q_u \\
K_k &= -Q_{uu}^{-1} Q_{ux}
\end{aligned}.
$$<p>After calculating the optimal control as a function of the next time step we can plug it back into Equation (1)</p>$$
\delta Q_k(x_k, u_k) = \frac{1}{2}
\begin{bmatrix}
\delta x_k \\
K \delta x + d
\end{bmatrix}^T
\begin{bmatrix}
Q_{xx} & Q_{xu} \\
Q_{ux} & Q_{uu}
\end{bmatrix}
\begin{bmatrix}
\delta x_k \\
K \delta x + d
\end{bmatrix}
\begin{bmatrix}
Q_x \\
Q_u
\end{bmatrix}^T
\begin{bmatrix}
\delta x_k \\
K \delta x + d
\end{bmatrix}
$$<p>By equating the result with Equation we get</p>$$\Delta V = \frac{1}{2} d^T Q_{uu} d + d^T Q_u$$$$s = Q_x + K^T Q_{uu} d + K^T Q_u + Q_{xu}^T d$$$$S = Q_{xx} + K^T Q_{uu} K + K^T Q_{ux} + Q_{ux}^T K$$<h4 id=forward-pass>Forward Pass<a hidden class=anchor aria-hidden=true href=#forward-pass>#</a></h4><p>Since the dynamics and the cost function are only approximated at each time step, it is necessary to iteratively solve the previous problem to successively get closer to the local minimum. After each backward pass solving for the optimal correction in control values, $\delta u_k^*$, these values are used to calculate a new state trajectory ( $X$) from the nominal trajectories $\bar{X}, \bar{U}$, often referred to as a &lsquo;&lsquo;rollout&rsquo;&rsquo;. The $\alpha$ term is used for a line search. This is done using the following algorithm:</p>$$\delta x = x_k - \bar{x}_k$$$$
\begin{aligned}
u_k &= \bar{u}_k + \delta u_k^* \\
&= \bar{u}_k + K_k \delta x_k + \alpha d_k
\end{aligned}
$$$$
x_{k+1} = f(x_k, u_k)
$$<p>where $\alpha$ is the step size, typically used to perform a simple line search.</p><h3 id=summary-2>Summary<a hidden class=anchor aria-hidden=true href=#summary-2>#</a></h3><p>The system dynamic is linearized and the objective function is expanded by the second order Taylor series.</p><h2 id=constrained-iterative-linear-quadratic-regulator>Constrained Iterative Linear Quadratic Regulator<a hidden class=anchor aria-hidden=true href=#constrained-iterative-linear-quadratic-regulator>#</a></h2><h3 id=discrete-time-finite-horizon-motion-planning-problem>Discrete-time Finite-horizon Motion Planning Problem<a hidden class=anchor aria-hidden=true href=#discrete-time-finite-horizon-motion-planning-problem>#</a></h3>$$
\begin{aligned}
\arg \min_{x, u} &\quad \left\{ \phi(x_N) + \sum_{k=0}^{N-1} L^k(x_k, u_k) \right\} \\
\text{s.t.} & \quad 
x_{k+1} = f^k(x_k, u_k), \quad k = 0, 1, \dots, N-1 \\
&\quad x_0 = x_{\text{start}} \\
&\quad g^k(x_k, u_k) < 0, \quad k = 0, 1, \dots, N-1 \\
&\quad g^N(x_N) < 0
\end{aligned}
$$<p><strong>Assumption 1</strong>: The system dynamic equation constraints are the only constraints in the problem.</p><p><strong>Assumption 2</strong>: The inequality constraints are separated to different time steps.</p><p><strong>Assumption 3</strong>: All the functions in the problem have continuous first and second order derivatives.</p><h3 id=handle-constraints>Handle Constraints<a hidden class=anchor aria-hidden=true href=#handle-constraints>#</a></h3><p>For inequality constraints, we use the barrier function to shape the constraints:</p>$$b(g(x, u)) = -\frac{1}{t} \log(-g(x, u))$$<figure style=text-align:center><img src=./resources/barrier-function.png alt="The log barrier function with different parameters." style="width:100%;margin:0 auto;display:block"><figcaption style=font-weight:400>The barrier function with different parameter, $t$.</figcaption></figure><h3 id=algorithm-1>Algorithm<a hidden class=anchor aria-hidden=true href=#algorithm-1>#</a></h3><figure style=text-align:center><img src=./resources/cilqr.png alt="The constrained iterative linear quadratic regulator algorithm." style="width:100%;margin:0 auto;display:block"><figcaption style=font-weight:400>Constrained iterative linear quadratic regulator algorithm [4].</figcaption></figure><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><p>[1] <a href=https://github.com/AtsushiSakai/PythonRobotics>https://github.com/AtsushiSakai/PythonRobotics</a></p><p>[2] J. Chen, W. Zhan, and M. Tomizuka, &ldquo;Autonomous driving motion planning with constrained iterative LQR,&rdquo; IEEE Transactions on Intelligent Vehicles, vol. 4, no. 2, pp. 244–254, Jun. 2019.</p><p>[3] <a href=https://github.com/pparmesh/Constrained_ILQR/tree/master/scripts>https://github.com/pparmesh/Constrained_ILQR/tree/master/scripts</a></p><p>[4] J. Chen, W. Zhan, and M. Tomizuka, &ldquo;Constrained iterative LQR for on-road autonomous driving motion planning,&rdquo; in Proc. 2017 IEEE 20th Int. Conf. Intell. Transp. Syst. (ITSC), Yokohama, Japan, Oct. 2017, pp. 2232–2238.</p><p>[5] &ldquo;Bézier curve,&rdquo; Wikipedia, The Free Encyclopedia, [Online]. Available: <a href=https://en.wikipedia.org/wiki/B%C3%A9zier_curve>https://en.wikipedia.org/wiki/B%C3%A9zier_curve</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://livey.github.io/tags/path-generating/>Path Generating</a></li><li><a href=https://livey.github.io/tags/annotation/>Annotation</a></li><li><a href=https://livey.github.io/tags/path-planning/>Path Planning</a></li><li><a href=https://livey.github.io/tags/motion-planning/>Motion Planning</a></li><li><a href=https://livey.github.io/tags/autonomous-driving/>Autonomous Driving</a></li></ul><nav class=paginav><a class=next href=https://livey.github.io/posts/2025-03-22-kalman-filters/><span class=title>Next »</span><br><span>Kalman Filters</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Path Generating on x" href="https://x.com/intent/tweet/?text=Path%20Generating&amp;url=https%3a%2f%2flivey.github.io%2fposts%2f2025-04-16-path-genrating%2f&amp;hashtags=PathGenerating%2cAnnotation%2cPathPlanning%2cMotionPlanning%2cAutonomousDriving"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Path Generating on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flivey.github.io%2fposts%2f2025-04-16-path-genrating%2f&amp;title=Path%20Generating&amp;summary=Path%20Generating&amp;source=https%3a%2f%2flivey.github.io%2fposts%2f2025-04-16-path-genrating%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Path Generating on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flivey.github.io%2fposts%2f2025-04-16-path-genrating%2f&title=Path%20Generating"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Path Generating on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flivey.github.io%2fposts%2f2025-04-16-path-genrating%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Path Generating on whatsapp" href="https://api.whatsapp.com/send?text=Path%20Generating%20-%20https%3a%2f%2flivey.github.io%2fposts%2f2025-04-16-path-genrating%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Path Generating on telegram" href="https://telegram.me/share/url?text=Path%20Generating&amp;url=https%3a%2f%2flivey.github.io%2fposts%2f2025-04-16-path-genrating%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Path Generating on ycombinator" href="https://news.ycombinator.com/submitlink?t=Path%20Generating&u=https%3a%2f%2flivey.github.io%2fposts%2f2025-04-16-path-genrating%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://livey.github.io/>Fuwei's Tech Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>